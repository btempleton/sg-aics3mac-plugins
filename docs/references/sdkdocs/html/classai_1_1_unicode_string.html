<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Adobe Illustrator SDK API Reference</title>
<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
<style type="text/css">body { background-color: white }</style>
<link rel="stylesheet" href="adobe.css" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body vlink="#996666" alink="#CC0000" leftmargin="24px" marginheight=
"0" marginwidth="0" topmargin="0">
<div id="overDiv" style=
"Z-INDEX:1000; VISIBILITY:hidden; POSITION:absolute"></div>
<a name="top"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0" ID="Table1">
<tr>
<td><img src="api.gif" alt="" height="80" width="750"
border="0" usemap="#topnavmap"></td>
<td width="100%" bgcolor="#CECECE">&nbsp;</td>
</tr>
</table>
<map name="topnavmap">
<area shape="rect" coords="10,10,50,60" href=
"http://www.adobe.com/" alt="Adobe.com">
</map>
<table border="0" cellpadding="0" cellspacing="0" width="745" ID="Table2">
<tr height="30">
<td width="15" height="30"><spacer type="block" width="15" height=
"30"></td>
</tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" ID="Table3">
<tr>
<td width="15"><spacer type="block" width="15" height="10"></td>
<td><!-- ENDHEADER -->
<!-- start-section: -->
<table border="0" cellpadding="5" cellspacing="5" id=
"ip-doxy-navbar">
<tr>
<td valign="bottom"><a class="qindex" href=
"index.html">Contents</a></td>
<td valign="bottom"><a class="qindex" href="group___suites.html">
Suites</a></td>
<td valign="bottom"><a class="qindex" href="annotated.html">
Classes</a></td>
<td valign="bottom"><a class="qindex" href="classes.html">
Class Index</a></td>
<td valign="bottom"><a class="qindex" href="functions.html">
Member Index</a></td>
</tr>
</table>
<!-- end-section: -->
<!-- Generated by Doxygen 1.4.7 -->
<div class="nav">
<a class="el" href="namespaceai.html">ai</a>::<a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a></div>
<h1>ai::UnicodeString Class Reference</h1><!-- doxytag: class="ai::UnicodeString" --><code>#include &lt;<a class="el" href="_i_a_i_unicode_string_8h-source.html">IAIUnicodeString.h</a>&gt;</code>
<p>
<a href="classai_1_1_unicode_string-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<code><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a></code> objects provide basic string functionality for Unicode-based strings, similar to that provided by the standard C string library. 
<p>
The contents of the string are treated as if all characters are represented as full 32-bit Unicode characters, which means you do not need to know the internal representation of the string, or deal with surrogate pairs during editing or searching operations. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A numeric value type (unsigned integer).  <a href="#8ad5f247dffa5659a99448bdd43e0901"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="_a_s_types_8h.html#262cd704d0b7689743bf26d701a2abe0">ASUInt32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value type for a UTF-32 character code.  <a href="#8297a74165a80120c668005608b830dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="_a_s_types_8h.html#b3d1cbba0a011d599bddd1643cf55b27">ASUnicode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#5ef6ba6fadb9aca3e0d44690fba83c10">UTF16Char</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Value type for a UTF-16 character code.  <a href="#5ef6ba6fadb9aca3e0d44690fba83c10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef590211e7f600f02751d33db53ad08e1551d9">kForm_NFD</a> = 0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Canonical Decomposition.  <a href="#003e58acaa5c6aeabea5ecccc8ef590211e7f600f02751d33db53ad08e1551d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef5902f80781672b12cee2317ed2124fff1a40">kForm_NFC</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Canonical Decomposition, followed by Canonical Composition.  <a href="#003e58acaa5c6aeabea5ecccc8ef5902f80781672b12cee2317ed2124fff1a40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef59025fb8f2bf47fbad58a7245af15c101cd1">kForm_NFKD</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compatibility Decomposition.  <a href="#003e58acaa5c6aeabea5ecccc8ef59025fb8f2bf47fbad58a7245af15c101cd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef59024aa321e1d5538d0f874d1e920a228dfe">kForm_NFKC</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparability Decomposition, followed by Canonical Composition.  <a href="#003e58acaa5c6aeabea5ecccc8ef59024aa321e1d5538d0f874d1e920a228dfe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef590252a589e112bf1e9a9e2e1a32a10f1702">kForm_DummyValue</a> = 0xFFFFFFFF</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do not use this.  <a href="#003e58acaa5c6aeabea5ecccc8ef590252a589e112bf1e9a9e2e1a32a10f1702"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef5902">NormalizedForm</a> { <br>
&nbsp;&nbsp;<a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef590211e7f600f02751d33db53ad08e1551d9">kForm_NFD</a> =  0, 
<a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef5902f80781672b12cee2317ed2124fff1a40">kForm_NFC</a>, 
<a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef59025fb8f2bf47fbad58a7245af15c101cd1">kForm_NFKD</a>, 
<a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef59024aa321e1d5538d0f874d1e920a228dfe">kForm_NFKC</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef590252a589e112bf1e9a9e2e1a32a10f1702">kForm_DummyValue</a> =  0xFFFFFFFF
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalization forms for use with the <code><a class="el" href="classai_1_1_unicode_string.html#86a5d7e9297a8d516187dcc92de2c678">normalize()</a></code> method.  <a href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef5902">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#324656006e89258eb2db255f93aefc6e">append</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends a string to this string.  <a href="#324656006e89258eb2db255f93aefc6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#aa108238d602dfe8e5db7acd6ad65305">append</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends a substring of a given string to this string.  <a href="#aa108238d602dfe8e5db7acd6ad65305"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#4992e419d9449552f5dea4b463929f5e">append</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count, <a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends a given number of copies of a given character to this string.  <a href="#4992e419d9449552f5dea4b463929f5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#aa5fc6890fd025c8f74d0dfad3ca1a7c">assign</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces the contents of this string with another string.  <a href="#aa5fc6890fd025c8f74d0dfad3ca1a7c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#a3b02d8f2417504f2a0682fe23f50245">assign</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> offset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces the contents of this string with a substring of another string.  <a href="#a3b02d8f2417504f2a0682fe23f50245"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#dafa1c48e8483402c53148f507c8c034">at</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> offset) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the UTF32 code point (character) from a string by position index.  <a href="#dafa1c48e8483402c53148f507c8c034"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#8d788795cb2e08f389b257aa65ab6a0e">clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases all characters in this string.  <a href="#8d788795cb2e08f389b257aa65ab6a0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#afa743fa3b9bc1e5963a112f099b444c">compare</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares this string and another string for equality.  <a href="#afa743fa3b9bc1e5963a112f099b444c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#6594b6876cd634f5f393feef58adfb5e">compare</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> pos, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> num, const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares this string and a substring of another string for equality.  <a href="#6594b6876cd634f5f393feef58adfb5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#adab08ecb04ca07a89ebfbeca23c087d">compare</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> pos, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> num, const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares a substring of this string and a substring of another string for equality.  <a href="#adab08ecb04ca07a89ebfbeca23c087d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#6bf102c16822bfdea5a99b5d24732f32">length</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of characters (UTF code points) in this string.  <a href="#6bf102c16822bfdea5a99b5d24732f32"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#cd4bb0697d0c99aebb10990d90695a76">empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports whether this string is an empty string.  <a href="#cd4bb0697d0c99aebb10990d90695a76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#30a6d92f1f29deca68311656c8ed4fc5">erase</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> pos=0, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count=<a class="el" href="classai_1_1_unicode_string.html#7ea0203fb3e3624dad66ce52d0cd9ee1">npos</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes characters (UTF code points) from this string.  <a href="#30a6d92f1f29deca68311656c8ed4fc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#8eb646fa490a66836ec9e76c0b0f3232">find</a> (<a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a> ch, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for a character in this string.  <a href="#8eb646fa490a66836ec9e76c0b0f3232"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#cc3b8421a29a7da1093f0e442070bfb7">find</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;target, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for a string within a subset of this string.  <a href="#cc3b8421a29a7da1093f0e442070bfb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#80b36d7bf75c8a331d9b9ee1edb5bc82">find</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;target, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for a substring within a subset of this string.  <a href="#80b36d7bf75c8a331d9b9ee1edb5bc82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#e8b5e855e4c95b4a5311594b21394d13">caseFind</a> (<a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a> ch, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for a character in this string, performing a caseless compare.  <a href="#e8b5e855e4c95b4a5311594b21394d13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#cca52d9b3d30c04512586e8d6789acee">caseFind</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;target, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for a string within a subset of this string, performing a caseless compare.  <a href="#cca52d9b3d30c04512586e8d6789acee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#75e97ee0a185dfd83c0dbe9f53ce12de">caseFind</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;target, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for a substring within a subset of this string, performing a caseless compare.  <a href="#75e97ee0a185dfd83c0dbe9f53ce12de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#2850b2329c1ec99ef3872a9221976af2">rfind</a> (<a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a> ch, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset=<a class="el" href="classai_1_1_unicode_string.html#7ea0203fb3e3624dad66ce52d0cd9ee1">npos</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for a character in this string, moving backward from a point in this string.  <a href="#2850b2329c1ec99ef3872a9221976af2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#622d1215edf37baf3699617cd8a45896">rfind</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;target, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset=<a class="el" href="classai_1_1_unicode_string.html#7ea0203fb3e3624dad66ce52d0cd9ee1">npos</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for a string within a subset of this string, moving backward from a point in this string.  <a href="#622d1215edf37baf3699617cd8a45896"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#c6060cef6158fa7e2f9f2bcdd87016ee">rfind</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;target, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for a substring within a subset of this string, moving backward from a point in this string.  <a href="#c6060cef6158fa7e2f9f2bcdd87016ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#dc4f884495cedd34050c5ccb7742d93b">find_first_of</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;target, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the first character of a string within a subset of this string.  <a href="#dc4f884495cedd34050c5ccb7742d93b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#3cabece201d93bc10e9c9b4c58282f90">find_first_of</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;target, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the first character of a string within a subset of this string.  <a href="#3cabece201d93bc10e9c9b4c58282f90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#1f6c0b6471f6b553aa95676e7f798bfc">find_last_of</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;target, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset=<a class="el" href="classai_1_1_unicode_string.html#7ea0203fb3e3624dad66ce52d0cd9ee1">npos</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the last character of a string within a subset of this string.  <a href="#1f6c0b6471f6b553aa95676e7f798bfc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#c18c33f1642c2be99dd07fa1ce64578a">find_last_of</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;target, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the last character of a string within a subset of this string.  <a href="#c18c33f1642c2be99dd07fa1ce64578a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#379a41bb7e65a97794852c11ef7782e0">find_first_not_of</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;target, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the first occurrence in this string of a character that is not in a target string.  <a href="#379a41bb7e65a97794852c11ef7782e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#627d580d99363ea5d7031e07cf50d2b0">find_first_not_of</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;target, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the first occurrence in a subset of this string of a character that is not in a target string.  <a href="#627d580d99363ea5d7031e07cf50d2b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#b859f1322ec6a3af9f6bd2d022bab734">find_last_not_of</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;target, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset=<a class="el" href="classai_1_1_unicode_string.html#7ea0203fb3e3624dad66ce52d0cd9ee1">npos</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the last occurrence in this string of a character that is not in a target string.  <a href="#b859f1322ec6a3af9f6bd2d022bab734"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#ae8f0cae728e7c3d677e6aaf5f284f8b">find_last_not_of</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;target, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the last occurrence in a subset of this string of a character that is not in a target string.  <a href="#ae8f0cae728e7c3d677e6aaf5f284f8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#646960184640d7511d5a8240be90a375">replace</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> pos, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> num, const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces a substring in this string with another string.  <a href="#646960184640d7511d5a8240be90a375"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#467fdf8e464ad3bc5625e2b399b26fec">replace</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> pos, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> num, const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces a substring in this string with a substring of another string.  <a href="#467fdf8e464ad3bc5625e2b399b26fec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#c4bdb644921739fed3de5a33d75f11a6">replace</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> pos, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> num, const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces a substring in this string with a substring of another string.  <a href="#c4bdb644921739fed3de5a33d75f11a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#1242c2f77c84793ed0a767e25342c3e3">insert</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> insertOffset, const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts a string into this string, inserting as many characters as will fit.  <a href="#1242c2f77c84793ed0a767e25342c3e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#37f1d3c0a5299c0309ebae2589e306c7">insert</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> insertOffset, const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> offset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts a substring into this string.  <a href="#37f1d3c0a5299c0309ebae2589e306c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#3ad1fdc457bdfe893b4be9b715e6e5b2">insert</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> insertOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count, <a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts repeated characters into this string.  <a href="#3ad1fdc457bdfe893b4be9b715e6e5b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#9cd63d06e37a51514891af44d9b73871">push_back</a> (<a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends a character to the end of this string.  <a href="#9cd63d06e37a51514891af44d9b73871"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#920cb859c0b6acc17cacef1ed8d40c28">resize</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count, <a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a> ch=<a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resizes this string, truncating it or adding characters as needed.  <a href="#920cb859c0b6acc17cacef1ed8d40c28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#8e6457d7551a5312873d0ea39a6ac355">size</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of characters (UTF code points) in this string.  <a href="#8e6457d7551a5312873d0ea39a6ac355"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#bb22f941b7ee228f520f46f6fdfb816a">substr</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> offset=0, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count=<a class="el" href="classai_1_1_unicode_string.html#7ea0203fb3e3624dad66ce52d0cd9ee1">npos</a>) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a copy of a substring of this string.  <a href="#bb22f941b7ee228f520f46f6fdfb816a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#caee8fa5df7a1e9811116bbc9743cc06">swap</a> (<a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the contents of this string with another string.  <a href="#caee8fa5df7a1e9811116bbc9743cc06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#7ac69d667bb2690268da913324d0a27f">operator=</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator.  <a href="#7ac69d667bb2690268da913324d0a27f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#ba1386691471a4f9e2f9b123faa15d8d">operator+=</a> (<a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append operator.  <a href="#ba1386691471a4f9e2f9b123faa15d8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#66f2924b04bd2ce4aba8aa848f0cea0f">operator+=</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append operator.  <a href="#66f2924b04bd2ce4aba8aa848f0cea0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#a4b45663ed330627d37846f3785b4774">operator[]</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> offset) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a character from this string.  <a href="#a4b45663ed330627d37846f3785b4774"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#35a9167db58d50d2a83f0720406b05b5">operator==</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality operator.  <a href="#35a9167db58d50d2a83f0720406b05b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#3e6b66db22ecce695e102cfa02550ef2">operator!=</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-equality operator.  <a href="#3e6b66db22ecce695e102cfa02550ef2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#efe85de341301d3e89d12a44be9e92e4">operator&lt;</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;rhs) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Less-than operator.  <a href="#efe85de341301d3e89d12a44be9e92e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#14b16483aaea15e38bab7fa6d2ff75b8">caseCompare</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares this string with another string, doing a caseless code-point-based comparison.  <a href="#14b16483aaea15e38bab7fa6d2ff75b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#448b537f8964432e0de7d83483c322bc">caseCompare</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> pos, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> num, const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares this string with a substring of another string, doing a caseless code-point-based comparison.  <a href="#448b537f8964432e0de7d83483c322bc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#aeb8c913a61d090aabb07422826359ab">caseCompare</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> pos, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> num, const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares a substring of this string with a substring of another string, doing a caseless code-point-based comparison.  <a href="#aeb8c913a61d090aabb07422826359ab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#1cfa9cb2ba96d725fe1e257eca51b517">canonicalCompare</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares this string with another string for canonical equivalence of their normalized forms (NFD or NFC).  <a href="#1cfa9cb2ba96d725fe1e257eca51b517"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#a734d3aca2f1a6fea3f921329b9c0167">canonicalCaseCompare</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;str) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares this string with another string for canonical equivalence of their normalized forms (NFD or NFC), performing a caseless compare.  <a href="#a734d3aca2f1a6fea3f921329b9c0167"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#86a5d7e9297a8d516187dcc92de2c678">normalize</a> (<a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef5902">NormalizedForm</a> form)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalizes this string in place into the specified form.  <a href="#86a5d7e9297a8d516187dcc92de2c678"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#1b87c1e1325c796f975aef1c9b31325f">hasSurrogates</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports whether this string contains surrogate pairs.  <a href="#1b87c1e1325c796f975aef1c9b31325f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#b57ef82c7433e3de96cd85b93dad15a2">utf_16</a> (const <a class="el" href="classai_1_1_unicode_string.html#5ef6ba6fadb9aca3e0d44690fba83c10">UTF16Char</a> *&amp;buffer) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a UTF-16 string from the contents of this string, in platform byte order.  <a href="#b57ef82c7433e3de96cd85b93dad15a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::basic_string&lt; <a class="el" href="_a_s_types_8h.html#b3d1cbba0a011d599bddd1643cf55b27">ASUnicode</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#34c3248cd0c62edafbe3b0cf0365b5ad">as_ASUnicode</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a 0-terminated UTF-16 string from the contents of this string, in platform byte order.  <a href="#34c3248cd0c62edafbe3b0cf0365b5ad"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#7bbbab0d858ca73ace94053775f5ac08">as_UTF8</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a UTF-8 string from the contents of this string.  <a href="#7bbbab0d858ca73ace94053775f5ac08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#c05a587f795f461a7d12c5e67966b0c7">as_Platform</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a platform-encoded version of this string.  <a href="#c05a587f795f461a7d12c5e67966b0c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#928e6a16b600630d9d6be316bc6d40f5">as_Roman</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an ISO Latin/Roman-encoded version of this string.  <a href="#928e6a16b600630d9d6be316bc6d40f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#35a3123d1f927f3c3b737b6312a5583b">getToBuffer</a> (char *buffer, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> bufferMax, <a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a> encoding) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the contents of this string to a provided buffer.  <a href="#35a3123d1f927f3c3b737b6312a5583b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#97cf5541faa48c9088d5950a48870646">getToBuffer</a> (const <a class="el" href="classai_1_1_p_str.html">PStr</a> &amp;pascalString, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> bufferMax, <a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a> encoding) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the contents of this string to a Pascal string in a provided buffer.  <a href="#97cf5541faa48c9088d5950a48870646"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#d454f8aef913d3f272ae4cb82450e275">as_ASUnicode</a> (<a class="el" href="_a_s_types_8h.html#b3d1cbba0a011d599bddd1643cf55b27">ASUnicode</a> *buffer, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> bufferMax) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the contents of this string to a Unicode string in a provided buffer.  <a href="#d454f8aef913d3f272ae4cb82450e275"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#53713b06ca58e39757ed4d59ff299599">as_Platform</a> (const <a class="el" href="classai_1_1_p_str.html">PStr</a> &amp;pascalString, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> bufferMax) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the contents of this string to a platform-encoded Pascal string in a provided buffer.  <a href="#53713b06ca58e39757ed4d59ff299599"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#273369d3b5da129163b6840db5925567">as_Platform</a> (char *buffer, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> bufferMax) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the contents of this string to a C string in a provided buffer.  <a href="#273369d3b5da129163b6840db5925567"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#2feba0bb4a91be64570eafacb278d9c7">as_Roman</a> (char *buffer, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> bufferMax) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the contents of this string to an ISO Latin/Roman-encoded C string in a provided buffer.  <a href="#2feba0bb4a91be64570eafacb278d9c7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#7221952ebb30d3580319c319c4f52c35">as_Roman</a> (const <a class="el" href="classai_1_1_p_str.html">PStr</a> &amp;pascalString, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> bufferMax) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the contents of this string to an ISO Latin/Roman-encoded Pascal string in a provided buffer.  <a href="#7221952ebb30d3580319c319c4f52c35"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#4b7c534be34db261c099b8013f14d05f">getInStdString</a> (<a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a> encoding) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a <code>std::string</code> from the contents of this string.  <a href="#4b7c534be34db261c099b8013f14d05f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#013e47f4bfa46c2855860bb1d32cfdb1">getAs</a> (<a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a> encoding, <a class="el" href="classai_1_1_auto_buffer.html">ai::AutoBuffer</a>&lt; char &gt; &amp;b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies the contents of this string to an <code>ai::AutoBuffer&lt;char&gt;</code>.  <a href="#013e47f4bfa46c2855860bb1d32cfdb1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#48a73adad344de0aaccac79118045485">deleteImpl</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Constructors &amp; Destructors</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#25de8efc316769fae8fc075d5449459c">UnicodeString</a> (void) AINOTHROW</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Empty string constructor.  <a href="#25de8efc316769fae8fc075d5449459c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#45c651b63ab15c860884977bfd7b195c">UnicodeString</a> (const char *string, long srcByteLen, <a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a> encoding=kAIPlatformCharacterEncoding)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from an encoded byte array.  <a href="#45c651b63ab15c860884977bfd7b195c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#74c1928e5471f7fce6853d529723460c">UnicodeString</a> (<a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count, <a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> using a copies of a single character.  <a href="#74c1928e5471f7fce6853d529723460c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#d7e0324c22c9cf2c4177fb3189aaf241">UnicodeString</a> (const char *string, <a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a> encoding=kAIPlatformCharacterEncoding)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience constructor from a <code>char</code> buffer that is known to be 0 terminated.  <a href="#d7e0324c22c9cf2c4177fb3189aaf241"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#f46ca3e42e7986dbc8dd81f376b51cf8">UnicodeString</a> (const std::string &amp;string, <a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a> encoding=kAIPlatformCharacterEncoding)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience constructor from a <code>std::string</code>.  <a href="#f46ca3e42e7986dbc8dd81f376b51cf8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#e307537f9802c479fdfcd8f18bcffe7a">UnicodeString</a> (const <a class="el" href="_a_s_types_8h.html#b3d1cbba0a011d599bddd1643cf55b27">ASUnicode</a> *string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor from 0-terminated, platform-byte-ordered, UTF-16 array.  <a href="#e307537f9802c479fdfcd8f18bcffe7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#6811ac6089877873395306a46607dcb9">UnicodeString</a> (const <a class="el" href="_a_i_types_8h.html#3be96ecb2582aa04f9c06190d8625dbf">ZRef</a> zStringKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor from the ZString referred to by a ZString key.  <a href="#6811ac6089877873395306a46607dcb9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#c74a7a63b72f33eff015b706dc5d62c9">UnicodeString</a> (const <a class="el" href="_a_s_types_8h.html#b3d1cbba0a011d599bddd1643cf55b27">ASUnicode</a> *string, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> srcUTF16Count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor from a non-0-terminated platform-byte-ordered, UTF-16 array.  <a href="#c74a7a63b72f33eff015b706dc5d62c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#9e4dbbc92709f9709f3abfc16402e5ac">UnicodeString</a> (const std::basic_string&lt; <a class="el" href="_a_s_types_8h.html#b3d1cbba0a011d599bddd1643cf55b27">ASUnicode</a> &gt; &amp;string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor from a <code>std::basic_string</code> of platform-byte-ordered <code>ASUnicode</code> characters.  <a href="#9e4dbbc92709f9709f3abfc16402e5ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#1d78d8e80586c65f2d727cf43e9c8e54">UnicodeString</a> (const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;s)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy Constructor, creates a copy of a string.  <a href="#1d78d8e80586c65f2d727cf43e9c8e54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#6cccf8fb9eb789be8d9d667cb8effbec">~UnicodeString</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#6cccf8fb9eb789be8d9d667cb8effbec"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Mac OS-specific Methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#40f42829765e5e6fac9f4981acb882f8">UnicodeString</a> (const CFStringRef &amp;cfString)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a Unicode string object from a Mac OS <code>CFString</code>.  <a href="#40f42829765e5e6fac9f4981acb882f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">CFStringRef&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#5ca3604196966634a3f9a08cdb20f8e8">as_CFString</a> (CFAllocatorRef alloc) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts the contents of this string to a Mac OS <code>CFString</code>.  <a href="#5ca3604196966634a3f9a08cdb20f8e8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Factory methods</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#d419e97a769dd407a9eeada4b7356f26">FromRoman</a> (const char *string, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a non-zero-terminated <code>char</code> array whose encoding is ISO Roman/Latin.  <a href="#d419e97a769dd407a9eeada4b7356f26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#355408b8cb63e36ca0d5eae8dd78faf4">FromRoman</a> (const char *string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a zero-terminated <code>char</code> array whose encoding is ISO Roman/Latin.  <a href="#355408b8cb63e36ca0d5eae8dd78faf4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#9ca27f164251783e13c3d0341d8d6615">FromRoman</a> (const std::string &amp;string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a <code>std::string</code> whose encoding is ISO Roman/Latin.  <a href="#9ca27f164251783e13c3d0341d8d6615"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#ba5c4b0d54b1f82d420ef7d510baf53b">FromRoman</a> (const <a class="el" href="classai_1_1const___p_str.html">const_PStr</a> &amp;pascalString)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a Pascal string whose encoding is ISO Roman/Latin.  <a href="#ba5c4b0d54b1f82d420ef7d510baf53b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#7ec786824fe7f2019dd9b35b211af3fa">FromPlatform</a> (const char *string, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a non-zero-terminated <code>char</code> array whose encoding is the current platform encoding.  <a href="#7ec786824fe7f2019dd9b35b211af3fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#07a808ac818411589453241af678668f">FromPlatform</a> (const char *string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a zero-terminated <code>char</code> array whose encoding is the current platform encoding.  <a href="#07a808ac818411589453241af678668f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#f4e181c67e3a9b5d04528055b051a59c">FromPlatform</a> (const std::string &amp;string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a <code>std::string</code> whose encoding is the current platform encoding.  <a href="#f4e181c67e3a9b5d04528055b051a59c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#d28fd9fbc50a72a375b4066746a310c0">FromPlatform</a> (const <a class="el" href="classai_1_1const___p_str.html">const_PStr</a> &amp;pascalString)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a Pascal string whose encoding is the current platform encoding.  <a href="#d28fd9fbc50a72a375b4066746a310c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#3f6bc6eb69eca9e943b7c6aa55fe906f">FromUTF8</a> (const char *string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a zero-terminated <code>char</code> array whose encoding is UTF8.  <a href="#3f6bc6eb69eca9e943b7c6aa55fe906f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#b8f90203d39411a4c6448d9b90c9aea9">FromUTF8</a> (const std::string &amp;string)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a <code>std::string</code> whose encoding is UTF8.  <a href="#b8f90203d39411a4c6448d9b90c9aea9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#eca4be6a31fb9629e4129d94c9928566">FromUTF8</a> (const <a class="el" href="classai_1_1const___p_str.html">const_PStr</a> &amp;pascalString)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a Pascal string whose encoding is UTF8.  <a href="#eca4be6a31fb9629e4129d94c9928566"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#7ea0203fb3e3624dad66ce52d0cd9ee1">npos</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of characters in this string.  <a href="#7ea0203fb3e3624dad66ce52d0cd9ee1"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classai_1_1_unicode_string.html#6e4796c344cfd3784e6ccf4da0255ec7">UnicodeString</a> (class CAIUnicodeStringImpl *impl)</td></tr>

</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="8ad5f247dffa5659a99448bdd43e0901"></a><!-- doxytag: member="ai::UnicodeString::size_type" ref="8ad5f247dffa5659a99448bdd43e0901" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A numeric value type (unsigned integer). 
<p>

</div>
</div><p>
<a class="anchor" name="5ef6ba6fadb9aca3e0d44690fba83c10"></a><!-- doxytag: member="ai::UnicodeString::UTF16Char" ref="5ef6ba6fadb9aca3e0d44690fba83c10" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_a_s_types_8h.html#b3d1cbba0a011d599bddd1643cf55b27">ASUnicode</a> <a class="el" href="classai_1_1_unicode_string.html#5ef6ba6fadb9aca3e0d44690fba83c10">ai::UnicodeString::UTF16Char</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Value type for a UTF-16 character code. 
<p>

</div>
</div><p>
<a class="anchor" name="8297a74165a80120c668005608b830dd"></a><!-- doxytag: member="ai::UnicodeString::UTF32TextChar" ref="8297a74165a80120c668005608b830dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_a_s_types_8h.html#262cd704d0b7689743bf26d701a2abe0">ASUInt32</a> <a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">ai::UnicodeString::UTF32TextChar</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Value type for a UTF-32 character code. 
<p>

</div>
</div><p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="003e58acaa5c6aeabea5ecccc8ef5902"></a><!-- doxytag: member="ai::UnicodeString::NormalizedForm" ref="003e58acaa5c6aeabea5ecccc8ef5902" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef5902">ai::UnicodeString::NormalizedForm</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normalization forms for use with the <code><a class="el" href="classai_1_1_unicode_string.html#86a5d7e9297a8d516187dcc92de2c678">normalize()</a></code> method. 
<p>
See <a href="http://www.unicode.org/reports/tr15/">http://www.unicode.org/reports/tr15/</a> for more information. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="003e58acaa5c6aeabea5ecccc8ef590211e7f600f02751d33db53ad08e1551d9"></a><!-- doxytag: member="kForm_NFD" ref="003e58acaa5c6aeabea5ecccc8ef590211e7f600f02751d33db53ad08e1551d9" args="" -->kForm_NFD</em>&nbsp;</td><td>
Canonical Decomposition. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="003e58acaa5c6aeabea5ecccc8ef5902f80781672b12cee2317ed2124fff1a40"></a><!-- doxytag: member="kForm_NFC" ref="003e58acaa5c6aeabea5ecccc8ef5902f80781672b12cee2317ed2124fff1a40" args="" -->kForm_NFC</em>&nbsp;</td><td>
Canonical Decomposition, followed by Canonical Composition. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="003e58acaa5c6aeabea5ecccc8ef59025fb8f2bf47fbad58a7245af15c101cd1"></a><!-- doxytag: member="kForm_NFKD" ref="003e58acaa5c6aeabea5ecccc8ef59025fb8f2bf47fbad58a7245af15c101cd1" args="" -->kForm_NFKD</em>&nbsp;</td><td>
Compatibility Decomposition. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="003e58acaa5c6aeabea5ecccc8ef59024aa321e1d5538d0f874d1e920a228dfe"></a><!-- doxytag: member="kForm_NFKC" ref="003e58acaa5c6aeabea5ecccc8ef59024aa321e1d5538d0f874d1e920a228dfe" args="" -->kForm_NFKC</em>&nbsp;</td><td>
Comparability Decomposition, followed by Canonical Composition. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="003e58acaa5c6aeabea5ecccc8ef590252a589e112bf1e9a9e2e1a32a10f1702"></a><!-- doxytag: member="kForm_DummyValue" ref="003e58acaa5c6aeabea5ecccc8ef590252a589e112bf1e9a9e2e1a32a10f1702" args="" -->kForm_DummyValue</em>&nbsp;</td><td>
Do not use this. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="25de8efc316769fae8fc075d5449459c"></a><!-- doxytag: member="ai::UnicodeString::UnicodeString" ref="25de8efc316769fae8fc075d5449459c" args="(void) AINOTHROW" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ai::UnicodeString::UnicodeString           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Empty string constructor. 
<p>
Creates a valid, empty string. This method is guaranteed to not throw any exceptions. 
</div>
</div><p>
<a class="anchor" name="45c651b63ab15c860884977bfd7b195c"></a><!-- doxytag: member="ai::UnicodeString::UnicodeString" ref="45c651b63ab15c860884977bfd7b195c" args="(const char *string, long srcByteLen, AICharacterEncoding encoding=kAIPlatformCharacterEncoding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ai::UnicodeString::UnicodeString           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>srcByteLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a>&nbsp;</td>
          <td class="paramname"> <em>encoding</em> = <code>kAIPlatformCharacterEncoding</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from an encoded byte array. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>Array of bytes to construct from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcByteLen</em>&nbsp;</td><td>Length of the array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>encoding</em>&nbsp;</td><td>Encoding of the contents of the byte array. Default is the current platform encoding </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="74c1928e5471f7fce6853d529723460c"></a><!-- doxytag: member="ai::UnicodeString::UnicodeString" ref="74c1928e5471f7fce6853d529723460c" args="(size_type count, UTF32TextChar ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ai::UnicodeString::UnicodeString           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> using a copies of a single character. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of characters to insert in this string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>The UTF32 code point (character) with which to initialize the string. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d7e0324c22c9cf2c4177fb3189aaf241"></a><!-- doxytag: member="ai::UnicodeString::UnicodeString" ref="d7e0324c22c9cf2c4177fb3189aaf241" args="(const char *string, AICharacterEncoding encoding=kAIPlatformCharacterEncoding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ai::UnicodeString::UnicodeString           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a>&nbsp;</td>
          <td class="paramname"> <em>encoding</em> = <code>kAIPlatformCharacterEncoding</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience constructor from a <code>char</code> buffer that is known to be 0 terminated. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>Initial contents. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>encoding</em>&nbsp;</td><td>Encoding of the contents of the byte array. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f46ca3e42e7986dbc8dd81f376b51cf8"></a><!-- doxytag: member="ai::UnicodeString::UnicodeString" ref="f46ca3e42e7986dbc8dd81f376b51cf8" args="(const std::string &amp;string, AICharacterEncoding encoding=kAIPlatformCharacterEncoding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ai::UnicodeString::UnicodeString           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a>&nbsp;</td>
          <td class="paramname"> <em>encoding</em> = <code>kAIPlatformCharacterEncoding</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convenience constructor from a <code>std::string</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>Initial contents. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>encoding</em>&nbsp;</td><td>Encoding of the contents of the byte array. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e307537f9802c479fdfcd8f18bcffe7a"></a><!-- doxytag: member="ai::UnicodeString::UnicodeString" ref="e307537f9802c479fdfcd8f18bcffe7a" args="(const ASUnicode *string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ai::UnicodeString::UnicodeString           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_a_s_types_8h.html#b3d1cbba0a011d599bddd1643cf55b27">ASUnicode</a> *&nbsp;</td>
          <td class="paramname"> <em>string</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor from 0-terminated, platform-byte-ordered, UTF-16 array. 
<p>
Surrogate pairs are okay. Exception raised if string is malformed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>Pointer to a valid 0-terminated array of UTF-16 <code>ASUnicode</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6811ac6089877873395306a46607dcb9"></a><!-- doxytag: member="ai::UnicodeString::UnicodeString" ref="6811ac6089877873395306a46607dcb9" args="(const ZRef zStringKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ai::UnicodeString::UnicodeString           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_a_i_types_8h.html#3be96ecb2582aa04f9c06190d8625dbf">ZRef</a>&nbsp;</td>
          <td class="paramname"> <em>zStringKey</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor from the ZString referred to by a ZString key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>zStringKey</em>&nbsp;</td><td>The ZString key. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c74a7a63b72f33eff015b706dc5d62c9"></a><!-- doxytag: member="ai::UnicodeString::UnicodeString" ref="c74a7a63b72f33eff015b706dc5d62c9" args="(const ASUnicode *string, size_type srcUTF16Count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ai::UnicodeString::UnicodeString           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_a_s_types_8h.html#b3d1cbba0a011d599bddd1643cf55b27">ASUnicode</a> *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>srcUTF16Count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor from a non-0-terminated platform-byte-ordered, UTF-16 array. 
<p>
Surrogate pairs are okay. Exception raised if string is malformed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>Pointer to an array of UTF-16 <code>ASUnicode</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcUTF16Count</em>&nbsp;</td><td>The number of UTF-16 code units to be read from string. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9e4dbbc92709f9709f3abfc16402e5ac"></a><!-- doxytag: member="ai::UnicodeString::UnicodeString" ref="9e4dbbc92709f9709f3abfc16402e5ac" args="(const std::basic_string&lt; ASUnicode &gt; &amp;string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ai::UnicodeString::UnicodeString           </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; <a class="el" href="_a_s_types_8h.html#b3d1cbba0a011d599bddd1643cf55b27">ASUnicode</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor from a <code>std::basic_string</code> of platform-byte-ordered <code>ASUnicode</code> characters. 
<p>
Surrogate pairs are okay. Exception raised if string is malformed. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>A <code>std::basic_string&lt;ASUnicode&gt;</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1d78d8e80586c65f2d727cf43e9c8e54"></a><!-- doxytag: member="ai::UnicodeString::UnicodeString" ref="1d78d8e80586c65f2d727cf43e9c8e54" args="(const UnicodeString &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ai::UnicodeString::UnicodeString           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy Constructor, creates a copy of a string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The string to copy. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6cccf8fb9eb789be8d9d667cb8effbec"></a><!-- doxytag: member="ai::UnicodeString::~UnicodeString" ref="6cccf8fb9eb789be8d9d667cb8effbec" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ai::UnicodeString::~UnicodeString           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>

</div>
</div><p>
<a class="anchor" name="40f42829765e5e6fac9f4981acb882f8"></a><!-- doxytag: member="ai::UnicodeString::UnicodeString" ref="40f42829765e5e6fac9f4981acb882f8" args="(const CFStringRef &amp;cfString)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ai::UnicodeString::UnicodeString           </td>
          <td>(</td>
          <td class="paramtype">const CFStringRef &amp;&nbsp;</td>
          <td class="paramname"> <em>cfString</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a Unicode string object from a Mac OS <code>CFString</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cfString</em>&nbsp;</td><td>The source <code>CFString</code>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6e4796c344cfd3784e6ccf4da0255ec7"></a><!-- doxytag: member="ai::UnicodeString::UnicodeString" ref="6e4796c344cfd3784e6ccf4da0255ec7" args="(class CAIUnicodeStringImpl *impl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ai::UnicodeString::UnicodeString           </td>
          <td>(</td>
          <td class="paramtype">class CAIUnicodeStringImpl *&nbsp;</td>
          <td class="paramname"> <em>impl</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="4992e419d9449552f5dea4b463929f5e"></a><!-- doxytag: member="ai::UnicodeString::append" ref="4992e419d9449552f5dea4b463929f5e" args="(size_type count, UTF32TextChar ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&amp; ai::UnicodeString::append           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Appends a given number of copies of a given character to this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters to append. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>The character to append. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to this Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="aa108238d602dfe8e5db7acd6ad65305"></a><!-- doxytag: member="ai::UnicodeString::append" ref="aa108238d602dfe8e5db7acd6ad65305" args="(const UnicodeString &amp;str, size_type startOffset, size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&amp; ai::UnicodeString::append           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Appends a substring of a given string to this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The source string of the substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based index of the first character in the substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The maximum number of characters in the substring. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to this Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="324656006e89258eb2db255f93aefc6e"></a><!-- doxytag: member="ai::UnicodeString::append" ref="324656006e89258eb2db255f93aefc6e" args="(const UnicodeString &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&amp; ai::UnicodeString::append           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Appends a string to this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to append. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to this Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d454f8aef913d3f272ae4cb82450e275"></a><!-- doxytag: member="ai::UnicodeString::as_ASUnicode" ref="d454f8aef913d3f272ae4cb82450e275" args="(ASUnicode *buffer, size_type bufferMax) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">UnicodeString::size_type</a> ai::UnicodeString::as_ASUnicode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_s_types_8h.html#b3d1cbba0a011d599bddd1643cf55b27">ASUnicode</a> *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>bufferMax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the contents of this string to a Unicode string in a provided buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to a Unicode string in which to return the 0-terminated copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufferMax</em>&nbsp;</td><td>The maximum byte count to write to the buffer, including the 0 terminator, or <code>NULL</code> to return the required size. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The size needed to write the entire string contents to a buffer, including a 0 terminator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="34c3248cd0c62edafbe3b0cf0365b5ad"></a><!-- doxytag: member="ai::UnicodeString::as_ASUnicode" ref="34c3248cd0c62edafbe3b0cf0365b5ad" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt;<a class="el" href="_a_s_types_8h.html#b3d1cbba0a011d599bddd1643cf55b27">ASUnicode</a>&gt; ai::UnicodeString::as_ASUnicode           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a 0-terminated UTF-16 string from the contents of this string, in platform byte order. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The contents of this string as UTF-16 code units. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5ca3604196966634a3f9a08cdb20f8e8"></a><!-- doxytag: member="ai::UnicodeString::as_CFString" ref="5ca3604196966634a3f9a08cdb20f8e8" args="(CFAllocatorRef alloc) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CFStringRef ai::UnicodeString::as_CFString           </td>
          <td>(</td>
          <td class="paramtype">CFAllocatorRef&nbsp;</td>
          <td class="paramname"> <em>alloc</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts the contents of this string to a Mac OS <code>CFString</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>alloc</em>&nbsp;</td><td>A valid <code>CFAllocatorRef</code> for allocating the <code>CFString</code>. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>An immutable <code>CFString</code> object containing chars, or <code>NULL</code> if there was a problem creating the object. You must dispose of this object when it is no longer needed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="273369d3b5da129163b6840db5925567"></a><!-- doxytag: member="ai::UnicodeString::as_Platform" ref="273369d3b5da129163b6840db5925567" args="(char *buffer, size_type bufferMax) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">UnicodeString::size_type</a> ai::UnicodeString::as_Platform           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>bufferMax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the contents of this string to a C string in a provided buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to a C string in which to return the 0-terminated copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufferMax</em>&nbsp;</td><td>The maximum byte count to write to the buffer, including the 0 terminator, or <code>NULL</code> to return the required size. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The size needed to write the entire string contents to a buffer, including a 0 terminator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="53713b06ca58e39757ed4d59ff299599"></a><!-- doxytag: member="ai::UnicodeString::as_Platform" ref="53713b06ca58e39757ed4d59ff299599" args="(const PStr &amp;pascalString, size_type bufferMax) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">UnicodeString::size_type</a> ai::UnicodeString::as_Platform           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_p_str.html">PStr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pascalString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>bufferMax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the contents of this string to a platform-encoded Pascal string in a provided buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pascalString</em>&nbsp;</td><td>A pointer to a Pascal string in which to return the 0-terminated copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufferMax</em>&nbsp;</td><td>The maximum byte count to write to the buffer, including the 0 terminator, or <code>NULL</code> to return the required size. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The size needed to write the entire string contents to a buffer, including a 0 terminator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c05a587f795f461a7d12c5e67966b0c7"></a><!-- doxytag: member="ai::UnicodeString::as_Platform" ref="c05a587f795f461a7d12c5e67966b0c7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ai::UnicodeString::as_Platform           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a platform-encoded version of this string. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The contents of this string as a UTF-8 encoded <code>std::string</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7221952ebb30d3580319c319c4f52c35"></a><!-- doxytag: member="ai::UnicodeString::as_Roman" ref="7221952ebb30d3580319c319c4f52c35" args="(const PStr &amp;pascalString, size_type bufferMax) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">UnicodeString::size_type</a> ai::UnicodeString::as_Roman           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_p_str.html">PStr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pascalString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>bufferMax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the contents of this string to an ISO Latin/Roman-encoded Pascal string in a provided buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pascalString</em>&nbsp;</td><td>A pointer to a Pascal string in which to return the 0-terminated copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufferMax</em>&nbsp;</td><td>The maximum byte count to write to the buffer, including the 0 terminator, or <code>NULL</code> to return the required size. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The size needed to write the entire string contents to a buffer, including a 0 terminator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2feba0bb4a91be64570eafacb278d9c7"></a><!-- doxytag: member="ai::UnicodeString::as_Roman" ref="2feba0bb4a91be64570eafacb278d9c7" args="(char *buffer, size_type bufferMax) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">UnicodeString::size_type</a> ai::UnicodeString::as_Roman           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>bufferMax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the contents of this string to an ISO Latin/Roman-encoded C string in a provided buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to a C string in which to return the 0-terminated copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufferMax</em>&nbsp;</td><td>The maximum byte count to write to the buffer, including the 0 terminator, or <code>NULL</code> to return the required size. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The size needed to write the entire string contents to a buffer, including a 0 terminator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="928e6a16b600630d9d6be316bc6d40f5"></a><!-- doxytag: member="ai::UnicodeString::as_Roman" ref="928e6a16b600630d9d6be316bc6d40f5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ai::UnicodeString::as_Roman           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates an ISO Latin/Roman-encoded version of this string. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The contents of this string as a UTF-8 encoded <code>std::string</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7bbbab0d858ca73ace94053775f5ac08"></a><!-- doxytag: member="ai::UnicodeString::as_UTF8" ref="7bbbab0d858ca73ace94053775f5ac08" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ai::UnicodeString::as_UTF8           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a UTF-8 string from the contents of this string. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The contents of this string as a UTF-8 encoded <code>std::string</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a3b02d8f2417504f2a0682fe23f50245"></a><!-- doxytag: member="ai::UnicodeString::assign" ref="a3b02d8f2417504f2a0682fe23f50245" args="(const UnicodeString &amp;str, size_type offset, size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&amp; ai::UnicodeString::assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replaces the contents of this string with a substring of another string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The source of the substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The 0-based index of the first character in the substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The maximum number of characters in the substring. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to this Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="aa5fc6890fd025c8f74d0dfad3ca1a7c"></a><!-- doxytag: member="ai::UnicodeString::assign" ref="aa5fc6890fd025c8f74d0dfad3ca1a7c" args="(const UnicodeString &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&amp; ai::UnicodeString::assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replaces the contents of this string with another string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The new contents. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to this Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dafa1c48e8483402c53148f507c8c034"></a><!-- doxytag: member="ai::UnicodeString::at" ref="dafa1c48e8483402c53148f507c8c034" args="(size_type offset) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a> ai::UnicodeString::at           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the UTF32 code point (character) from a string by position index. 
<p>
Raises <code><a class="el" href="group___errors.html#g8d699068b7a70440cf8b648d38e39f60">kUnicodeStringBadIndex</a></code> exception if offset is out of range. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The 0-based index of the character. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The UTF32 value of the character. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a734d3aca2f1a6fea3f921329b9c0167"></a><!-- doxytag: member="ai::UnicodeString::canonicalCaseCompare" ref="a734d3aca2f1a6fea3f921329b9c0167" args="(const UnicodeString &amp;str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ai::UnicodeString::canonicalCaseCompare           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares this string with another string for canonical equivalence of their normalized forms (NFD or NFC), performing a caseless compare. 
<p>
This requires temporary allocation of memory, and can throw out-of-memory errors.<p>
Uninitialized strings are equal to other uninitialized strings and empty strings. Uninitialized and empty strings are less than initialized, non-empty strings. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The comparison string (right side of compare). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the strings are equal. <br>
 Positive if this string is greater than the comparison string. <br>
 Negative if this string is less than the comparison string.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Substring comparison of non-normalized strings is not directly available. You can create substrings and pass them to this method. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1cfa9cb2ba96d725fe1e257eca51b517"></a><!-- doxytag: member="ai::UnicodeString::canonicalCompare" ref="1cfa9cb2ba96d725fe1e257eca51b517" args="(const UnicodeString &amp;str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ai::UnicodeString::canonicalCompare           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares this string with another string for canonical equivalence of their normalized forms (NFD or NFC). 
<p>
This requires temporary allocation of memory, and can throw out-of-memory errors.<p>
Uninitialized strings are equal to other uninitialized strings and empty strings. Uninitialized and empty strings are less than initialized, non-empty strings. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The comparison string (right side of compare). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the strings are equal. <br>
 Positive if this string is greater than the comparison string. <br>
 Negative if this string is less than the comparison string.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Substring comparison of non-normalized strings is not directly available. You can create substrings and pass them to this method. </dd></dl>

</div>
</div><p>
<a class="anchor" name="aeb8c913a61d090aabb07422826359ab"></a><!-- doxytag: member="ai::UnicodeString::caseCompare" ref="aeb8c913a61d090aabb07422826359ab" args="(size_type pos, size_type num, const UnicodeString &amp;str, size_type startOffset, size_type count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ai::UnicodeString::caseCompare           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares a substring of this string with a substring of another string, doing a caseless code-point-based comparison. 
<p>
Uninitialized strings are equal to other uninitialized strings and empty strings. Uninitialized and empty strings are less than initialized, non-empty strings. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The 0-based position index of the first character of the substring of this string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>The number of characters in the substring of this string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The comparison string (right side of compare). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index of the first character of the substring of the comparison string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters in the substring of the comparison string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if this substring and the comparison substring are equal. <br>
 Positive if this substring is greater than the comparison substring. <br>
 Negative if this substring is less than the comparison substring. </dd></dl>

</div>
</div><p>
<a class="anchor" name="448b537f8964432e0de7d83483c322bc"></a><!-- doxytag: member="ai::UnicodeString::caseCompare" ref="448b537f8964432e0de7d83483c322bc" args="(size_type pos, size_type num, const UnicodeString &amp;str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ai::UnicodeString::caseCompare           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares this string with a substring of another string, doing a caseless code-point-based comparison. 
<p>
Uninitialized strings are equal to other uninitialized strings and empty strings. Uninitialized and empty strings are less than initialized, non-empty strings. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The 0-based position index of the first character of the substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>The number of characters to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The comparison string (right side of compare). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if this string and the substring are equal. <br>
 Positive if this string is greater than the substring. <br>
 Negative if this string is less than the substring. </dd></dl>

</div>
</div><p>
<a class="anchor" name="14b16483aaea15e38bab7fa6d2ff75b8"></a><!-- doxytag: member="ai::UnicodeString::caseCompare" ref="14b16483aaea15e38bab7fa6d2ff75b8" args="(const UnicodeString &amp;str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ai::UnicodeString::caseCompare           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares this string with another string, doing a caseless code-point-based comparison. 
<p>
Uninitialized strings are equal to other uninitialized strings and empty strings. Uninitialized and empty strings are less than initialized, non-empty strings. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The comparison string (right side of compare). </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the strings are equal. <br>
 Positive if this string is greater than the comparison string. <br>
 Negative if this string is less than the comparison string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="75e97ee0a185dfd83c0dbe9f53ce12de"></a><!-- doxytag: member="ai::UnicodeString::caseFind" ref="75e97ee0a185dfd83c0dbe9f53ce12de" args="(const UnicodeString &amp;target, size_type startOffset, size_type count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::caseFind           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for a substring within a subset of this string, performing a caseless compare. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The string to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters in the target string to search for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the first character of the target substring within this string, if found, or the number of characters in this string (<code>npos</code>) if the target substring is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cca52d9b3d30c04512586e8d6789acee"></a><!-- doxytag: member="ai::UnicodeString::caseFind" ref="cca52d9b3d30c04512586e8d6789acee" args="(const UnicodeString &amp;target, size_type startOffset=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::caseFind           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for a string within a subset of this string, performing a caseless compare. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The string to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the first character of the target string within this string, if found, or the number of characters in this string (<code>npos</code>) if the target string is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e8b5e855e4c95b4a5311594b21394d13"></a><!-- doxytag: member="ai::UnicodeString::caseFind" ref="e8b5e855e4c95b4a5311594b21394d13" args="(UTF32TextChar ch, size_type startOffset=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::caseFind           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for a character in this string, performing a caseless compare. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>The character to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the found character, or the number of characters in this string (<code>npos</code>) if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8d788795cb2e08f389b257aa65ab6a0e"></a><!-- doxytag: member="ai::UnicodeString::clear" ref="8d788795cb2e08f389b257aa65ab6a0e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai::UnicodeString::clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases all characters in this string. 
<p>
Same as <code>erase(0, npos)</code>. Uninitialized strings remain unchanged. <dl compact><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><code><a class="el" href="classai_1_1_unicode_string.html#30a6d92f1f29deca68311656c8ed4fc5">erase()</a></code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="adab08ecb04ca07a89ebfbeca23c087d"></a><!-- doxytag: member="ai::UnicodeString::compare" ref="adab08ecb04ca07a89ebfbeca23c087d" args="(size_type pos, size_type num, const UnicodeString &amp;str, size_type startOffset, size_type count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ai::UnicodeString::compare           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares a substring of this string and a substring of another string for equality. 
<p>
Uninitialized strings are equal to other uninitialized strings and to empty strings.Uninitialized and empty strings are less than initialized, non-empty strings. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The 0-based index of the first character of the substring in this string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>The number of characters to compare in this string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The source of the substring to compare against (right side of compare).. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based index of the first character of the substring of <code>str</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters from <code>str</code> to compare. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Zero if the two substrings are equal. <br>
 Negative if the substring of this string is less than the substring of <code>str</code>. <br>
 Positive if the substring of this string is greater than the substring of <code>str</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6594b6876cd634f5f393feef58adfb5e"></a><!-- doxytag: member="ai::UnicodeString::compare" ref="6594b6876cd634f5f393feef58adfb5e" args="(size_type pos, size_type num, const UnicodeString &amp;str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ai::UnicodeString::compare           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares this string and a substring of another string for equality. 
<p>
Uninitialized strings are equal to other uninitialized strings and to empty strings.Uninitialized and empty strings are less than initialized, non-empty strings. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The 0-based index of the first character of the substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>The number of characters to compare. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The source of the substring to compare against (right side of compare).. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Zero if this string and the substring are equal. <br>
 Negative if this string is less than the substring of <code>str</code>. <br>
 Positive if this string is greater than the substring of <code>str</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="afa743fa3b9bc1e5963a112f099b444c"></a><!-- doxytag: member="ai::UnicodeString::compare" ref="afa743fa3b9bc1e5963a112f099b444c" args="(const UnicodeString &amp;str) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ai::UnicodeString::compare           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares this string and another string for equality. 
<p>
Uninitialized strings are equal to other uninitialized strings and to empty strings.Uninitialized and empty strings are less than initialized, non-empty strings. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to compare against (right side of compare).. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Zero if the two strings are equal. <br>
 Negative if this string is less than <code>str</code>. <br>
 Positive if this string is greater than <code>str</code>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="48a73adad344de0aaccac79118045485"></a><!-- doxytag: member="ai::UnicodeString::deleteImpl" ref="48a73adad344de0aaccac79118045485" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai::UnicodeString::deleteImpl           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cd4bb0697d0c99aebb10990d90695a76"></a><!-- doxytag: member="ai::UnicodeString::empty" ref="cd4bb0697d0c99aebb10990d90695a76" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ai::UnicodeString::empty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reports whether this string is an empty string. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>True if the string is empty. </dd></dl>

</div>
</div><p>
<a class="anchor" name="30a6d92f1f29deca68311656c8ed4fc5"></a><!-- doxytag: member="ai::UnicodeString::erase" ref="30a6d92f1f29deca68311656c8ed4fc5" args="(size_type pos=0, size_type count=npos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&amp; ai::UnicodeString::erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em> = <code><a class="el" href="classai_1_1_unicode_string.html#7ea0203fb3e3624dad66ce52d0cd9ee1">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes characters (UTF code points) from this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The 0-based position index of the first character to remove. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters to remove. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to this Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="80b36d7bf75c8a331d9b9ee1edb5bc82"></a><!-- doxytag: member="ai::UnicodeString::find" ref="80b36d7bf75c8a331d9b9ee1edb5bc82" args="(const UnicodeString &amp;target, size_type startOffset, size_type count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::find           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for a substring within a subset of this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The string to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters in the target string to search for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the first character of the target substring within this string, if found, or the number of characters in this string (<code>npos</code>) if the target substring is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cc3b8421a29a7da1093f0e442070bfb7"></a><!-- doxytag: member="ai::UnicodeString::find" ref="cc3b8421a29a7da1093f0e442070bfb7" args="(const UnicodeString &amp;target, size_type startOffset=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::find           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for a string within a subset of this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The string to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the first character of the target string within this string, if found, or the number of characters in this string (<code>npos</code>) if the target string is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8eb646fa490a66836ec9e76c0b0f3232"></a><!-- doxytag: member="ai::UnicodeString::find" ref="8eb646fa490a66836ec9e76c0b0f3232" args="(UTF32TextChar ch, size_type startOffset=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::find           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for a character in this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>The character to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the found character, or the number of characters in this string (<code>npos</code>) if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="627d580d99363ea5d7031e07cf50d2b0"></a><!-- doxytag: member="ai::UnicodeString::find_first_not_of" ref="627d580d99363ea5d7031e07cf50d2b0" args="(const UnicodeString &amp;target, size_type startOffset, size_type count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::find_first_not_of           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the first occurrence in a subset of this string of a character that is not in a target string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The target string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters in this string to search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the character within this string, if found, or the number of characters in this string (<code>npos</code>) if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="379a41bb7e65a97794852c11ef7782e0"></a><!-- doxytag: member="ai::UnicodeString::find_first_not_of" ref="379a41bb7e65a97794852c11ef7782e0" args="(const UnicodeString &amp;target, size_type startOffset=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::find_first_not_of           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the first occurrence in this string of a character that is not in a target string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The target string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the character within this string, if found, or the number of characters in this string (<code>npos</code>) if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3cabece201d93bc10e9c9b4c58282f90"></a><!-- doxytag: member="ai::UnicodeString::find_first_of" ref="3cabece201d93bc10e9c9b4c58282f90" args="(const UnicodeString &amp;target, size_type startOffset, size_type count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::find_first_of           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the first character of a string within a subset of this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The string to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters in the substring to search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the first character of the target string within this string, if found, or the number of characters in this string (<code>npos</code>) if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="dc4f884495cedd34050c5ccb7742d93b"></a><!-- doxytag: member="ai::UnicodeString::find_first_of" ref="dc4f884495cedd34050c5ccb7742d93b" args="(const UnicodeString &amp;target, size_type startOffset=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::find_first_of           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the first character of a string within a subset of this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The string to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the first character of the target string within this string, if found, or the number of characters in this string (<code>npos</code>) if the first character of the target string is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ae8f0cae728e7c3d677e6aaf5f284f8b"></a><!-- doxytag: member="ai::UnicodeString::find_last_not_of" ref="ae8f0cae728e7c3d677e6aaf5f284f8b" args="(const UnicodeString &amp;target, size_type startOffset, size_type count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::find_last_not_of           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the last occurrence in a subset of this string of a character that is not in a target string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The target string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters in this string to search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the character within this string, if found, or the number of characters in this string (<code>npos</code>) if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b859f1322ec6a3af9f6bd2d022bab734"></a><!-- doxytag: member="ai::UnicodeString::find_last_not_of" ref="b859f1322ec6a3af9f6bd2d022bab734" args="(const UnicodeString &amp;target, size_type startOffset=npos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::find_last_not_of           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em> = <code><a class="el" href="classai_1_1_unicode_string.html#7ea0203fb3e3624dad66ce52d0cd9ee1">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the last occurrence in this string of a character that is not in a target string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The target string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the character within this string, if found, or the number of characters in this string (<code>npos</code>) if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c18c33f1642c2be99dd07fa1ce64578a"></a><!-- doxytag: member="ai::UnicodeString::find_last_of" ref="c18c33f1642c2be99dd07fa1ce64578a" args="(const UnicodeString &amp;target, size_type startOffset, size_type count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::find_last_of           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the last character of a string within a subset of this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The string containing the character to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters in this string in which to search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the last character of the target string within this string, if found, or the number of characters in this string (<code>npos</code>) if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1f6c0b6471f6b553aa95676e7f798bfc"></a><!-- doxytag: member="ai::UnicodeString::find_last_of" ref="1f6c0b6471f6b553aa95676e7f798bfc" args="(const UnicodeString &amp;target, size_type startOffset=npos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::find_last_of           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em> = <code><a class="el" href="classai_1_1_unicode_string.html#7ea0203fb3e3624dad66ce52d0cd9ee1">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the last character of a string within a subset of this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The string containing the character to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the last character of the target string within this string, if found, or the number of characters in this string (<code>npos</code>) if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d28fd9fbc50a72a375b4066746a310c0"></a><!-- doxytag: member="ai::UnicodeString::FromPlatform" ref="d28fd9fbc50a72a375b4066746a310c0" args="(const const_PStr &amp;pascalString)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> ai::UnicodeString::FromPlatform           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1const___p_str.html">const_PStr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pascalString</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a Pascal string whose encoding is the current platform encoding. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pascalString</em>&nbsp;</td><td>The Pascal string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f4e181c67e3a9b5d04528055b051a59c"></a><!-- doxytag: member="ai::UnicodeString::FromPlatform" ref="f4e181c67e3a9b5d04528055b051a59c" args="(const std::string &amp;string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> ai::UnicodeString::FromPlatform           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a <code>std::string</code> whose encoding is the current platform encoding. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>The string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="07a808ac818411589453241af678668f"></a><!-- doxytag: member="ai::UnicodeString::FromPlatform" ref="07a808ac818411589453241af678668f" args="(const char *string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> ai::UnicodeString::FromPlatform           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a zero-terminated <code>char</code> array whose encoding is the current platform encoding. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>The <code>char</code> array. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ec786824fe7f2019dd9b35b211af3fa"></a><!-- doxytag: member="ai::UnicodeString::FromPlatform" ref="7ec786824fe7f2019dd9b35b211af3fa" args="(const char *string, size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> ai::UnicodeString::FromPlatform           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a non-zero-terminated <code>char</code> array whose encoding is the current platform encoding. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>The <code>char</code> array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of bytes (chars) in the string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba5c4b0d54b1f82d420ef7d510baf53b"></a><!-- doxytag: member="ai::UnicodeString::FromRoman" ref="ba5c4b0d54b1f82d420ef7d510baf53b" args="(const const_PStr &amp;pascalString)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> ai::UnicodeString::FromRoman           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1const___p_str.html">const_PStr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pascalString</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a Pascal string whose encoding is ISO Roman/Latin. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pascalString</em>&nbsp;</td><td>The Pascal string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ca27f164251783e13c3d0341d8d6615"></a><!-- doxytag: member="ai::UnicodeString::FromRoman" ref="9ca27f164251783e13c3d0341d8d6615" args="(const std::string &amp;string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> ai::UnicodeString::FromRoman           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a <code>std::string</code> whose encoding is ISO Roman/Latin. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>The string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="355408b8cb63e36ca0d5eae8dd78faf4"></a><!-- doxytag: member="ai::UnicodeString::FromRoman" ref="355408b8cb63e36ca0d5eae8dd78faf4" args="(const char *string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> ai::UnicodeString::FromRoman           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a zero-terminated <code>char</code> array whose encoding is ISO Roman/Latin. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>The <code>char</code> array. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d419e97a769dd407a9eeada4b7356f26"></a><!-- doxytag: member="ai::UnicodeString::FromRoman" ref="d419e97a769dd407a9eeada4b7356f26" args="(const char *string, size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> ai::UnicodeString::FromRoman           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a non-zero-terminated <code>char</code> array whose encoding is ISO Roman/Latin. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>The <code>char</code> array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>the number of bytes (chars) in the string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eca4be6a31fb9629e4129d94c9928566"></a><!-- doxytag: member="ai::UnicodeString::FromUTF8" ref="eca4be6a31fb9629e4129d94c9928566" args="(const const_PStr &amp;pascalString)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> ai::UnicodeString::FromUTF8           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1const___p_str.html">const_PStr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pascalString</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a Pascal string whose encoding is UTF8. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pascalString</em>&nbsp;</td><td>The Pascal string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b8f90203d39411a4c6448d9b90c9aea9"></a><!-- doxytag: member="ai::UnicodeString::FromUTF8" ref="b8f90203d39411a4c6448d9b90c9aea9" args="(const std::string &amp;string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> ai::UnicodeString::FromUTF8           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>string</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a <code>std::string</code> whose encoding is UTF8. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>The string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3f6bc6eb69eca9e943b7c6aa55fe906f"></a><!-- doxytag: member="ai::UnicodeString::FromUTF8" ref="3f6bc6eb69eca9e943b7c6aa55fe906f" args="(const char *string)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> ai::UnicodeString::FromUTF8           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>string</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> from a zero-terminated <code>char</code> array whose encoding is UTF8. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>The <code>char</code> array. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The Unicode string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="013e47f4bfa46c2855860bb1d32cfdb1"></a><!-- doxytag: member="ai::UnicodeString::getAs" ref="013e47f4bfa46c2855860bb1d32cfdb1" args="(AICharacterEncoding encoding, ai::AutoBuffer&lt; char &gt; &amp;b) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::getAs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a>&nbsp;</td>
          <td class="paramname"> <em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_auto_buffer.html">ai::AutoBuffer</a>&lt; char &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the contents of this string to an <code>ai::AutoBuffer&lt;char&gt;</code>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>encoding</em>&nbsp;</td><td>The encoding for the result. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The buffer in which to return the result. The resulting contents might not be 0 terminated. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of characters (bytes) returned in the buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4b7c534be34db261c099b8013f14d05f"></a><!-- doxytag: member="ai::UnicodeString::getInStdString" ref="4b7c534be34db261c099b8013f14d05f" args="(AICharacterEncoding encoding) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ai::UnicodeString::getInStdString           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a>&nbsp;</td>
          <td class="paramname"> <em>encoding</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a <code>std::string</code> from the contents of this string. 
<p>
Can throw an out-of-memory error. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>encoding</em>&nbsp;</td><td>The encoding for the result. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The string result. </dd></dl>

</div>
</div><p>
<a class="anchor" name="97cf5541faa48c9088d5950a48870646"></a><!-- doxytag: member="ai::UnicodeString::getToBuffer" ref="97cf5541faa48c9088d5950a48870646" args="(const PStr &amp;pascalString, size_type bufferMax, AICharacterEncoding encoding) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::getToBuffer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_p_str.html">PStr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pascalString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>bufferMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a>&nbsp;</td>
          <td class="paramname"> <em>encoding</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the contents of this string to a Pascal string in a provided buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pascalString</em>&nbsp;</td><td>A pointer to a Pascal string in which to return the 0-terminated copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufferMax</em>&nbsp;</td><td>The maximum byte count to write to the buffer, including the 0 terminator, or <code>NULL</code> to return the required size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>encoding</em>&nbsp;</td><td>The encoding for the result. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The size needed to write the entire string contents to a buffer, including a 0 terminator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="35a3123d1f927f3c3b737b6312a5583b"></a><!-- doxytag: member="ai::UnicodeString::getToBuffer" ref="35a3123d1f927f3c3b737b6312a5583b" args="(char *buffer, size_type bufferMax, AICharacterEncoding encoding) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::getToBuffer           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>bufferMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a>&nbsp;</td>
          <td class="paramname"> <em>encoding</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies the contents of this string to a provided buffer. 
<p>
This method follows the <code>strlcpy</code> paradigm. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to a byte array in which to return the 0-terminated copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufferMax</em>&nbsp;</td><td>The maximum byte count to write to the buffer, including the 0 terminator, or <code>NULL</code> to return the required size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>encoding</em>&nbsp;</td><td>The encoding for the result. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The size needed to write the entire string contents to a buffer, including a 0 terminator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b87c1e1325c796f975aef1c9b31325f"></a><!-- doxytag: member="ai::UnicodeString::hasSurrogates" ref="1b87c1e1325c796f975aef1c9b31325f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ai::UnicodeString::hasSurrogates           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reports whether this string contains surrogate pairs. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>True if there are surrogate pairs in this string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3ad1fdc457bdfe893b4be9b715e6e5b2"></a><!-- doxytag: member="ai::UnicodeString::insert" ref="3ad1fdc457bdfe893b4be9b715e6e5b2" args="(size_type insertOffset, size_type count, UTF32TextChar ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&amp; ai::UnicodeString::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>insertOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts repeated characters into this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>insertOffset</em>&nbsp;</td><td>The 0-based position index in this string after which to start the insertion. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of copies of the character to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>The character to insert. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>This string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="37f1d3c0a5299c0309ebae2589e306c7"></a><!-- doxytag: member="ai::UnicodeString::insert" ref="37f1d3c0a5299c0309ebae2589e306c7" args="(size_type insertOffset, const UnicodeString &amp;str, size_type offset, size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp; ai::UnicodeString::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>insertOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a substring into this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>insertOffset</em>&nbsp;</td><td>The 0-based position index in this string after which to start the insertion. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The source string of the substring to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>he 0-based position index of the first character of the substring to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters to insert. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>This string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1242c2f77c84793ed0a767e25342c3e3"></a><!-- doxytag: member="ai::UnicodeString::insert" ref="1242c2f77c84793ed0a767e25342c3e3" args="(size_type insertOffset, const UnicodeString &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&amp; ai::UnicodeString::insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>insertOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a string into this string, inserting as many characters as will fit. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>insertOffset</em>&nbsp;</td><td>The 0-based position index in this string after which to start the insertion. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to be partially or wholly inserted. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>This string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6bf102c16822bfdea5a99b5d24732f32"></a><!-- doxytag: member="ai::UnicodeString::length" ref="6bf102c16822bfdea5a99b5d24732f32" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::length           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the number of characters (UTF code points) in this string. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of UTF code points in this string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="86a5d7e9297a8d516187dcc92de2c678"></a><!-- doxytag: member="ai::UnicodeString::normalize" ref="86a5d7e9297a8d516187dcc92de2c678" args="(NormalizedForm form)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&amp; ai::UnicodeString::normalize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef5902">NormalizedForm</a>&nbsp;</td>
          <td class="paramname"> <em>form</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normalizes this string in place into the specified form. 
<p>
Normalization may require re-allocation of the string. If this happens, the method can throw out-of-memory errors. On failure, this string remains unmodified. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>form</em>&nbsp;</td><td>The form with which to normalize the string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to this string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3e6b66db22ecce695e102cfa02550ef2"></a><!-- doxytag: member="ai::UnicodeString::operator!=" ref="3e6b66db22ecce695e102cfa02550ef2" args="(const UnicodeString &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ai::UnicodeString::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Non-equality operator. 
<p>
Does a simple, direct, code-point-based comparison. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The string with which to compare this string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the strings are not equal. </dd></dl>

</div>
</div><p>
<a class="anchor" name="66f2924b04bd2ce4aba8aa848f0cea0f"></a><!-- doxytag: member="ai::UnicodeString::operator+=" ref="66f2924b04bd2ce4aba8aa848f0cea0f" args="(const UnicodeString &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&amp; ai::UnicodeString::operator+=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The Unicode string object to append to this one. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to this string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba1386691471a4f9e2f9b123faa15d8d"></a><!-- doxytag: member="ai::UnicodeString::operator+=" ref="ba1386691471a4f9e2f9b123faa15d8d" args="(UTF32TextChar ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&amp; ai::UnicodeString::operator+=           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>The character to append to this string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to this string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="efe85de341301d3e89d12a44be9e92e4"></a><!-- doxytag: member="ai::UnicodeString::operator&lt;" ref="efe85de341301d3e89d12a44be9e92e4" args="(const UnicodeString &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ai::UnicodeString::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Less-than operator. 
<p>
Does a simple, direct, code-point-based comparison. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The string with which to compare this string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if this string is less than the comparison string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ac69d667bb2690268da913324d0a27f"></a><!-- doxytag: member="ai::UnicodeString::operator=" ref="7ac69d667bb2690268da913324d0a27f" args="(const UnicodeString &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&amp; ai::UnicodeString::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The Unicode string object to assign into this one. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to this string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="35a9167db58d50d2a83f0720406b05b5"></a><!-- doxytag: member="ai::UnicodeString::operator==" ref="35a9167db58d50d2a83f0720406b05b5" args="(const UnicodeString &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ai::UnicodeString::operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality operator. 
<p>
Does a simple, direct, code-point-based comparison. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rhs</em>&nbsp;</td><td>The string with which to compare this string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the strings are equal. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a4b45663ed330627d37846f3785b4774"></a><!-- doxytag: member="ai::UnicodeString::operator[]" ref="a4b45663ed330627d37846f3785b4774" args="(size_type offset) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a> ai::UnicodeString::operator[]           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a character from this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The 0-based position index of the character. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The character.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This behavior differs from <code>std::basic_string</code> operator[]. This method returns the character at the given offset. <code>std::basic_string::operator[]</code> returns a writeable reference to the elopement at the given offset. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9cd63d06e37a51514891af44d9b73871"></a><!-- doxytag: member="ai::UnicodeString::push_back" ref="9cd63d06e37a51514891af44d9b73871" args="(UTF32TextChar ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai::UnicodeString::push_back           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Appends a character to the end of this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>The character to append. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c4bdb644921739fed3de5a33d75f11a6"></a><!-- doxytag: member="ai::UnicodeString::replace" ref="c4bdb644921739fed3de5a33d75f11a6" args="(size_type pos, size_type num, const UnicodeString &amp;str, size_type startOffset, size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp; ai::UnicodeString::replace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replaces a substring in this string with a substring of another string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The 0-based position index in this string at which to start the replacement. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>The number of characters in this string to replace. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The replacement string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index of the first character of the replacement substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters in the replacement substring, starting at the offset. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>This string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="467fdf8e464ad3bc5625e2b399b26fec"></a><!-- doxytag: member="ai::UnicodeString::replace" ref="467fdf8e464ad3bc5625e2b399b26fec" args="(size_type pos, size_type num, const UnicodeString &amp;str, size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&amp; ai::UnicodeString::replace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replaces a substring in this string with a substring of another string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The 0-based position index in this string at which to start the replacement. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>The number of characters in this string to replace. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The replacement string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters in the replacement substring, starting at the first character. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>This string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="646960184640d7511d5a8240be90a375"></a><!-- doxytag: member="ai::UnicodeString::replace" ref="646960184640d7511d5a8240be90a375" args="(size_type pos, size_type num, const UnicodeString &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a>&amp; ai::UnicodeString::replace           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Replaces a substring in this string with another string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The 0-based position index in this string at which to start the replacement. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>The number of characters in this string to replace. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The replacement string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>This string object. </dd></dl>

</div>
</div><p>
<a class="anchor" name="920cb859c0b6acc17cacef1ed8d40c28"></a><!-- doxytag: member="ai::UnicodeString::resize" ref="920cb859c0b6acc17cacef1ed8d40c28" args="(size_type count, UTF32TextChar ch=UTF32TextChar())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai::UnicodeString::resize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em> = <code><a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resizes this string, truncating it or adding characters as needed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The new number of characters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>The UTF code point value with which to initialize new elements, if the size of the string is increased. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c6060cef6158fa7e2f9f2bcdd87016ee"></a><!-- doxytag: member="ai::UnicodeString::rfind" ref="c6060cef6158fa7e2f9f2bcdd87016ee" args="(const UnicodeString &amp;target, size_type startOffset, size_type count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::rfind           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for a substring within a subset of this string, moving backward from a point in this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The string to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters in the target string to search for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the first character of the target substring within this string, if found, or the number of characters in this string (<code>npos</code>) if the target substring is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="622d1215edf37baf3699617cd8a45896"></a><!-- doxytag: member="ai::UnicodeString::rfind" ref="622d1215edf37baf3699617cd8a45896" args="(const UnicodeString &amp;target, size_type startOffset=npos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::rfind           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em> = <code><a class="el" href="classai_1_1_unicode_string.html#7ea0203fb3e3624dad66ce52d0cd9ee1">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for a string within a subset of this string, moving backward from a point in this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The string to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the first character of the target string within this string, if found, or the number of characters in this string (<code>npos</code>) if the target string is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2850b2329c1ec99ef3872a9221976af2"></a><!-- doxytag: member="ai::UnicodeString::rfind" ref="2850b2329c1ec99ef3872a9221976af2" args="(UTF32TextChar ch, size_type startOffset=npos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::rfind           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">UTF32TextChar</a>&nbsp;</td>
          <td class="paramname"> <em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>startOffset</em> = <code><a class="el" href="classai_1_1_unicode_string.html#7ea0203fb3e3624dad66ce52d0cd9ee1">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for a character in this string, moving backward from a point in this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>The character to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based position index in this string at which to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based position index of the found character, or the number of characters in this string (<code>npos</code>) if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8e6457d7551a5312873d0ea39a6ac355"></a><!-- doxytag: member="ai::UnicodeString::size" ref="8e6457d7551a5312873d0ea39a6ac355" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> ai::UnicodeString::size           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the number of characters (UTF code points) in this string. 
<p>
This is the same as <code><a class="el" href="classai_1_1_unicode_string.html#6bf102c16822bfdea5a99b5d24732f32">length()</a></code>. <dl compact><dt><b>Returns:</b></dt><dd>The number of UTF code points in this string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bb22f941b7ee228f520f46f6fdfb816a"></a><!-- doxytag: member="ai::UnicodeString::substr" ref="bb22f941b7ee228f520f46f6fdfb816a" args="(size_type offset=0, size_type count=npos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> ai::UnicodeString::substr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>count</em> = <code><a class="el" href="classai_1_1_unicode_string.html#7ea0203fb3e3624dad66ce52d0cd9ee1">npos</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a copy of a substring of this string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The 0-based position index of the first character to be copied to the substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The maximum number of characters to copy to the new substring. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A <code><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a></code> object containing the requested substring. </dd></dl>

</div>
</div><p>
<a class="anchor" name="caee8fa5df7a1e9811116bbc9743cc06"></a><!-- doxytag: member="ai::UnicodeString::swap" ref="caee8fa5df7a1e9811116bbc9743cc06" args="(UnicodeString &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ai::UnicodeString::swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classai_1_1_unicode_string.html">UnicodeString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps the contents of this string with another string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to swap. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Nothing. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b57ef82c7433e3de96cd85b93dad15a2"></a><!-- doxytag: member="ai::UnicodeString::utf_16" ref="b57ef82c7433e3de96cd85b93dad15a2" args="(const UTF16Char *&amp;buffer) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> ai::UnicodeString::utf_16           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classai_1_1_unicode_string.html#5ef6ba6fadb9aca3e0d44690fba83c10">UTF16Char</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>buffer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a UTF-16 string from the contents of this string, in platform byte order. 
<p>
This method does not allocate any memory, and returns in constant time. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A reference to a const pointer to <code>UTF16Char</code> in which to return the contents of this string as UTF-16 code units. Can be 0 if this string is empty. This buffer pointer is only valid at most for the lifetime of this string. The buffer is not guaranteed to be 0 terminated. Use <code><a class="el" href="classai_1_1_unicode_string.html#34c3248cd0c62edafbe3b0cf0365b5ad">as_ASUnicode()</a></code> to guarantee a 0-terminated buffer. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of UTF-16 characters in the returned buffer. </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="7ea0203fb3e3624dad66ce52d0cd9ee1"></a><!-- doxytag: member="ai::UnicodeString::npos" ref="7ea0203fb3e3624dad66ce52d0cd9ee1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">size_type</a> <a class="el" href="classai_1_1_unicode_string.html#7ea0203fb3e3624dad66ce52d0cd9ee1">ai::UnicodeString::npos</a><code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of characters in this string. 
<p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_i_a_i_unicode_string_8h-source.html">IAIUnicodeString.h</a></ul>

<hr id="decoratehere">
<hr>
<!-- STARTFOOTER -->
</td>
</tr>
<tr>
<td width="15"><spacer type="block" width="15" height="10"></td>
<td><!-- ENDHEADER -->
<!-- start-section: -->
<table border="0" cellpadding="5" cellspacing="5" id="Table2">
<tr>
<td valign="bottom"><a class="qindex" href=
"index.html">Contents</a></td>
<td valign="bottom"><a class="qindex" href="group___suites.html">
Suites</a></td>
<td valign="bottom"><a class="qindex" href="annotated.html">
Classes</a></td>
<td valign="bottom"><a class="qindex" href="classes.html">
Class Index</a></td>
<td valign="bottom"><a class="qindex" href="functions.html">
Member Index</a></td>
</tr>
</table>
</td>
</tr>
<!-- </table> --></table>
<table border="0" cellpadding="0" cellspacing="0" width="745" id=
"Table3">
<tr height="30">
<td colspan="3" height="30"><spacer type="block" height="30"></td>
</tr>
<tr height="45">
<td width="20"><spacer type="block" width="20" height="45"></td>
<td width="115"><img src="asn.gif" width="114"
height="45" border="0" alt="Adobe Solutions Network"></td>
<td width="610"><spacer type="block" width="610" height="45"></td>
</tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="745" id=
"Table4">
<tr height="10">
<td width="20" height="10"><spacer type="block" width="20" height=
"10"></td>
<td width="705" height="10"><spacer type="block" height="10"></td>
<td width="20" height="10"><spacer type="blockheight=10"></td>
</tr>
<tr height="3">
<td width="10" align="right"><spacer type="block" width="10"
height="1"></td>
<td width="705" background="1dot.gif" alt=""><spacer type="block"
width="1" height="3"></td>
<td width="10"><spacer type="block" width="10" height="1"></td>
</tr>
<tr height="10">
<td colspan="3"><spacer type="block" height="10"></td>
</tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="745" id=
"Table5">
<tr>
<td width="20">&nbsp;</td>
<td width="725" valign="top">
<table border="0" cellpadding="0" cellspacing="0" id="Table6">
<tr>
<td colspan="13" valign="top" align="left" class="bio">Copyright
&#169; 2007 Adobe Systems Incorporated. All rights reserved.</td>
</tr>
<tr height="3">
<td colspan="13" height="3"><spacer type="block" width="20" height=
"3"></td>
</tr>
<tr>
<td valign="top"><a href="http://www.adobe.com/misc/copyright.html"
class="footerlink">Terms of Use</a></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td width="1" background="1dot.gif"><spacer type="block" width="1"
height="1"></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td valign="top"><a href="http://www.adobe.com/misc/privacy.html"
class="footerlink">Online Privacy Policy</a></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td width="1" background="1dot.gif"><spacer type="block" width="1"
height="1"></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td valign="top"><a href="http://access.adobe.com" class=
"footerlink">Adobe and accessibility</a></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td width="1" background="1dot.gif"><spacer type="block" width="1"
height="1"></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td valign="top"><a href=
"http://www.adobe.com/aboutadobe/antipiracy/main.html" class=
"footerlink">Avoid software piracy</a></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td width="1" background="1dot.gif"><spacer type="block" width="1"
height="1"></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td valign="top"><a href="http://www.adobe.com/misc/agreement.html"
class="footerlink">Permissions and Trademarks</a></td>
</tr>
<tr height="40">
<td colspan="12" height="40"><spacer type="block" width="20"
height="40"></td>
<td height="40"><img src="1ptrans.gif" width="20" height=
"40">&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
</body>
</html>

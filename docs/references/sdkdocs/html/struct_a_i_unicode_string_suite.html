<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Adobe Illustrator SDK API Reference</title>
<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
<style type="text/css">body { background-color: white }</style>
<link rel="stylesheet" href="adobe.css" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body vlink="#996666" alink="#CC0000" leftmargin="24px" marginheight=
"0" marginwidth="0" topmargin="0">
<div id="overDiv" style=
"Z-INDEX:1000; VISIBILITY:hidden; POSITION:absolute"></div>
<a name="top"></a>
<table width="100%" border="0" cellspacing="0" cellpadding="0" ID="Table1">
<tr>
<td><img src="api.gif" alt="" height="80" width="750"
border="0" usemap="#topnavmap"></td>
<td width="100%" bgcolor="#CECECE">&nbsp;</td>
</tr>
</table>
<map name="topnavmap">
<area shape="rect" coords="10,10,50,60" href=
"http://www.adobe.com/" alt="Adobe.com">
</map>
<table border="0" cellpadding="0" cellspacing="0" width="745" ID="Table2">
<tr height="30">
<td width="15" height="30"><spacer type="block" width="15" height=
"30"></td>
</tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" ID="Table3">
<tr>
<td width="15"><spacer type="block" width="15" height="10"></td>
<td><!-- ENDHEADER -->
<!-- start-section: -->
<table border="0" cellpadding="5" cellspacing="5" id=
"ip-doxy-navbar">
<tr>
<td valign="bottom"><a class="qindex" href=
"index.html">Contents</a></td>
<td valign="bottom"><a class="qindex" href="group___suites.html">
Suites</a></td>
<td valign="bottom"><a class="qindex" href="annotated.html">
Classes</a></td>
<td valign="bottom"><a class="qindex" href="classes.html">
Class Index</a></td>
<td valign="bottom"><a class="qindex" href="functions.html">
Member Index</a></td>
</tr>
</table>
<!-- end-section: -->
<!-- Generated by Doxygen 1.4.7 -->
<h1>AIUnicodeStringSuite Struct Reference<br>
<small>
[<a class="el" href="group___suites.html">API Suite List</a>]</small>
</h1><!-- doxytag: class="AIUnicodeStringSuite" --><code>#include &lt;<a class="el" href="_a_i_unicode_string_8h-source.html">AIUnicodeString.h</a>&gt;</code>
<p>
<a href="struct_a_i_unicode_string_suite-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
This suite provides utilities that allow you to create and manipulate Unicode strings. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>It is recommended that you use the wrapper class, <code><a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a></code>, rather than calling these functions directly.</dd></dl>
<ul>
<li>Acquire this suite using <code><a class="el" href="struct_s_p_basic_suite.html#b191b4fcb7967214396d91afa4c2ead5">SPBasicSuite::AcquireSuite()</a></code> with the constants <code><a class="el" href="_a_i_unicode_string_8h.html#04755c735b5bdd961efba9b3adcce1e3">kAIUnicodeStringSuite</a></code> and <code><a class="el" href="_a_i_unicode_string_8h.html#44b722bbbff177c447bb3401b04006e7">kAIUnicodeStringVersion</a></code>. </li>
</ul>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#22a78f79f91a81f961d490e330987be7">Initialize</a> )(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const char *string, long srcByteLen, <a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a> encoding)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes a Unicode string with the contents of a C string.  <a href="#22a78f79f91a81f961d490e330987be7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#b400768e7d63eed5f69e89146545a889">InitializeUTF16</a> )(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="_a_s_types_8h.html#b3d1cbba0a011d599bddd1643cf55b27">ASUnicode</a> *utfs, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> srcUTF16Count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes a Unicode string with the contents of a UTF-16 encoded string.  <a href="#b400768e7d63eed5f69e89146545a889"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#0ca65e5ca52b5c50b0f87fa748acedc5">InitializeUTF32Char</a> )(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count, <a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">ai::UnicodeString::UTF32TextChar</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes a Unicode string with a single UTF-32 code point (character) repeated a given number of times.  <a href="#0ca65e5ca52b5c50b0f87fa748acedc5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#e711efe39d8af61ecaa4b760b1419b92">Destroy</a> )(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes the contents of a Unicode string, and reset it to an uninitialized state.  <a href="#e711efe39d8af61ecaa4b760b1419b92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#70a273ba96a331227ac0472eaf3013fe">Append</a> )(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends one Unicode string to another.  <a href="#70a273ba96a331227ac0472eaf3013fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#a72ed1faec4bc210ddc986ce35bedd92">AppendSubString</a> )(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends a sub-string of one Unicode string to another.  <a href="#a72ed1faec4bc210ddc986ce35bedd92"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#7f1b3f9c98ad3ee4c104200d7e7c27d5">Assign</a> )(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns one Unicode string to another.  <a href="#7f1b3f9c98ad3ee4c104200d7e7c27d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#2003219935027332b997d2804744e01d">Copy</a> )(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies one Unicode string into another.  <a href="#2003219935027332b997d2804744e01d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#cae375503fffb743803ae707c3866e83">GetChar</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> position, <a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">ai::UnicodeString::UTF32TextChar</a> &amp;ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the UTF-32 code point at an index position in a Unicode string.  <a href="#cae375503fffb743803ae707c3866e83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#670c9d9eeea268b5dc0dbf00ed3fe052">Clear</a> )(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the contents of a Unicode string.  <a href="#670c9d9eeea268b5dc0dbf00ed3fe052"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#449ff7db8c5a9d569840298ab3e43397">Compare</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> pos, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> num, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compares substrings in two Unicode strings.  <a href="#449ff7db8c5a9d569840298ab3e43397"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#6ef6cbec6ad538dba0b2566efb389a77">CaseCompare</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> pos, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> num, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a caseless comparison of substrings in two Unicode strings.  <a href="#6ef6cbec6ad538dba0b2566efb389a77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#066f86e8967b21f1eef196b9d437bf9a">CanonicalCompare</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, int &amp;compareResult)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a normalized comparison of substrings in two Unicode strings.  <a href="#066f86e8967b21f1eef196b9d437bf9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#0078fdd48d2065200325deb52c46c5f5">CanonicalCaseCompare</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, int &amp;compareResult)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a normalized, caseless comparison of substrings in two Unicode strings.  <a href="#0078fdd48d2065200325deb52c46c5f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#c71ae8d6c6814b91585ebe87cbd1e70b">Length</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the number of UTF-32 code points (characters) in a Unicode string.  <a href="#c71ae8d6c6814b91585ebe87cbd1e70b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#54b1aaa5084ac23c3e956aec86a5f8f1">AIBool8</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#9d2a40e24ddc0acc4b03ebf54c76c58a">Empty</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports whether a Unicode string is empty.  <a href="#9d2a40e24ddc0acc4b03ebf54c76c58a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#043c00445bf40a79e1770af03d4d3900">Erase</a> )(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases characters from a Unicode string.  <a href="#043c00445bf40a79e1770af03d4d3900"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#236c40647d8b46903954f2039a0b0ef2">FindChar</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">ai::UnicodeString::UTF32TextChar</a> ch, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the first occurrence of a character in a substring of a Unicode string.  <a href="#236c40647d8b46903954f2039a0b0ef2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#cc52a52897c791d0e0561a629bac7849">FindString</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the first occurrence of an entire string within a substring of a Unicode string.  <a href="#cc52a52897c791d0e0561a629bac7849"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#5a3fcb4827363a4965653b14376413f4">FindSubString</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the first occurrence of a substring of one Unicode string within a substring of another Unicode string.  <a href="#5a3fcb4827363a4965653b14376413f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#7b86824a8ce4a308b341309c0924051d">CaseFindSubString</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the first occurrence of a substring of one Unicode string within a substring of another Unicode string, performing a caseless compare.  <a href="#7b86824a8ce4a308b341309c0924051d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#6eb055fb2df5b3472045fbb67c25706a">RFindChar</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">ai::UnicodeString::UTF32TextChar</a> ch, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the last occurrence of a character in a substring of a Unicode string.  <a href="#6eb055fb2df5b3472045fbb67c25706a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#acef0c8a9eb1a7238989e087fcb512e8">RFindString</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the last occurrence of an entire string within a substring of a Unicode string.  <a href="#acef0c8a9eb1a7238989e087fcb512e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#862a13fabce2a19c8bf225fb1df0e6ca">RFindSubString</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the last occurrence of a substring of one Unicode string within a substring of another Unicode string.  <a href="#862a13fabce2a19c8bf225fb1df0e6ca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#d59a9358fac097911821db0d02ffe36c">FindFirstOf</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches for the first occurrence of any character from a subset of one Unicode string in a substring of another string.  <a href="#d59a9358fac097911821db0d02ffe36c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#98b0b1f0c4c4be9c0120e3772dc093a6">FindFirstNotOf</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches in a Unicode string for the first occurrence of any character that does not appear in a subset of another string.  <a href="#98b0b1f0c4c4be9c0120e3772dc093a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#120103d5246ef50da216abfe2a9ea26b">FindLastOf</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches in a Unicode string for the last character that also appears in a substring of another string.  <a href="#120103d5246ef50da216abfe2a9ea26b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#b062a94858464f8d4d9cb0e932c861e6">FindLastNotOf</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Searches in a Unicode string for the last character that does not appear in a substring of another string.  <a href="#b062a94858464f8d4d9cb0e932c861e6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#223f03095ba7b6651820e9416920e4fb">Resize</a> )(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count, <a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">ai::UnicodeString::UTF32TextChar</a> ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resizes a Unicode string to hold a given number of characters, truncating or padding it as needed.  <a href="#223f03095ba7b6651820e9416920e4fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#f88bfe2a5dcf90b63de394f8b9ddf807">SubStr</a> )(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;subString, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> offset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a substring of a Unicode string.  <a href="#f88bfe2a5dcf90b63de394f8b9ddf807"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#0b5d1e3e571817f6c1f50aa5182c990b">SwapStr</a> )(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swaps the contents of two Unicode strings.  <a href="#0b5d1e3e571817f6c1f50aa5182c990b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#54b1aaa5084ac23c3e956aec86a5f8f1">AIBool8</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#155cf6abd6aada91b5968ea46487a3dd">HasSurrogates</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reports whether a Unicode string contains surrogate pairs.  <a href="#155cf6abd6aada91b5968ea46487a3dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#6ee2d158f698446ff40b5f660bd24d88">UTF_16</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html#5ef6ba6fadb9aca3e0d44690fba83c10">ai::UnicodeString::UTF16Char</a> *&amp;buffer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a read-only pointer to a buffer that contains UTF-16 encoded characters in platform byte order, for a given Unicode string.  <a href="#6ee2d158f698446ff40b5f660bd24d88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#93edf6befab1293d5d80becc3fa9ebd1">GetAs</a> )(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a> encoding, <a class="el" href="classai_1_1_auto_buffer.html">ai::AutoBuffer</a>&lt; char &gt; &amp;buffer, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> &amp;bufferByteCount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the contents of a Unicode string in a given encoding.  <a href="#93edf6befab1293d5d80becc3fa9ebd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#3aae9222264ef574241c52e53c92c92d">InitializeZString</a> )(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="_a_i_types_8h.html#3be96ecb2582aa04f9c06190d8625dbf">ZRef</a> zStringKey)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes a Unicode string from a ZString.  <a href="#3aae9222264ef574241c52e53c92c92d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_i_unicode_string_suite.html#74ded83c6d7144658c1bf0b6cfc4a4df">Normalize</a> )(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef5902">ai::UnicodeString::NormalizedForm</a> form)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalizes a Unicode string.  <a href="#74ded83c6d7144658c1bf0b6cfc4a4df"></a><br></td></tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="70a273ba96a331227ac0472eaf3013fe"></a><!-- doxytag: member="AIUnicodeStringSuite::Append" ref="70a273ba96a331227ac0472eaf3013fe" args=")(ai::UnicodeString &amp;str, const ai::UnicodeString &amp;str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#70a273ba96a331227ac0472eaf3013fe">AIUnicodeStringSuite::Append</a>)(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Appends one Unicode string to another. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to append to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The string to append. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a72ed1faec4bc210ddc986ce35bedd92"></a><!-- doxytag: member="AIUnicodeStringSuite::AppendSubString" ref="a72ed1faec4bc210ddc986ce35bedd92" args=")(ai::UnicodeString &amp;str, const ai::UnicodeString &amp;str2, ai::UnicodeString::size_type startOffset, ai::UnicodeString::size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#a72ed1faec4bc210ddc986ce35bedd92">AIUnicodeStringSuite::AppendSubString</a>)(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Appends a sub-string of one Unicode string to another. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to append to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The source string for the substring to append. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based character offset for the substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>the maximum number of characters for the substring. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7f1b3f9c98ad3ee4c104200d7e7c27d5"></a><!-- doxytag: member="AIUnicodeStringSuite::Assign" ref="7f1b3f9c98ad3ee4c104200d7e7c27d5" args=")(ai::UnicodeString &amp;str, const ai::UnicodeString &amp;str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#7f1b3f9c98ad3ee4c104200d7e7c27d5">AIUnicodeStringSuite::Assign</a>)(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns one Unicode string to another. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The destination string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The source string. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0078fdd48d2065200325deb52c46c5f5"></a><!-- doxytag: member="AIUnicodeStringSuite::CanonicalCaseCompare" ref="0078fdd48d2065200325deb52c46c5f5" args=")(const ai::UnicodeString &amp;str, const ai::UnicodeString &amp;str2, int &amp;compareResult)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#0078fdd48d2065200325deb52c46c5f5">AIUnicodeStringSuite::CanonicalCaseCompare</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, int &amp;compareResult)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a normalized, caseless comparison of substrings in two Unicode strings. 
<p>
Strings are case folded in a locale-independent manner prior to comparison. Uninitialized strings are equal to other uninitialized strings and empty strings, and are less than initialized, non-empty strings. (Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The first string (left side of compare). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The 0-based offset for the first character of the first substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>The number of characters in the first substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The second string (right side of compare). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based offset for the first character of the second substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters in the second substring. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the substrings are equal. <br>
 Positive if the first substring is greater than the second. <br>
 Negative if the second substring is greater than the first. </dd></dl>

</div>
</div><p>
<a class="anchor" name="066f86e8967b21f1eef196b9d437bf9a"></a><!-- doxytag: member="AIUnicodeStringSuite::CanonicalCompare" ref="066f86e8967b21f1eef196b9d437bf9a" args=")(const ai::UnicodeString &amp;str, const ai::UnicodeString &amp;str2, int &amp;compareResult)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#066f86e8967b21f1eef196b9d437bf9a">AIUnicodeStringSuite::CanonicalCompare</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, int &amp;compareResult)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a normalized comparison of substrings in two Unicode strings. 
<p>
Uninitialized strings are equal to other uninitialized strings and empty strings, and are less than initialized, non-empty strings. (Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The first string (left side of compare). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The 0-based offset for the first character of the first substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>The number of characters in the first substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The second string (right side of compare). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based offset for the first character of the second substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters in the second substring. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the substrings are equal. <br>
 Positive if the first substring is greater than the second. <br>
 Negative if the second substring is greater than the first. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6ef6cbec6ad538dba0b2566efb389a77"></a><!-- doxytag: member="AIUnicodeStringSuite::CaseCompare" ref="6ef6cbec6ad538dba0b2566efb389a77" args=")(const ai::UnicodeString &amp;str, ai::UnicodeString::size_type pos, ai::UnicodeString::size_type num, const ai::UnicodeString &amp;str2, ai::UnicodeString::size_type startOffset, ai::UnicodeString::size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI int(* <a class="el" href="struct_a_i_unicode_string_suite.html#6ef6cbec6ad538dba0b2566efb389a77">AIUnicodeStringSuite::CaseCompare</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> pos, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> num, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a caseless comparison of substrings in two Unicode strings. 
<p>
Strings are case folded in a locale-independent manner prior to comparison. Uninitialized strings are equal to other uninitialized strings and empty strings, and are less than initialized, non-empty strings. (Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The first string (left side of compare). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The 0-based offset for the first character of the first substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>The number of characters in the first substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The second string (right side of compare). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based offset for the first character of the second substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters in the second substring. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the substrings are equal. <br>
 Positive if the first substring is greater than the second. <br>
 Negative if the second substring is greater than the first. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b86824a8ce4a308b341309c0924051d"></a><!-- doxytag: member="AIUnicodeStringSuite::CaseFindSubString" ref="7b86824a8ce4a308b341309c0924051d" args=")(const ai::UnicodeString &amp;str, const ai::UnicodeString &amp;str2, ai::UnicodeString::size_type startOffset, ai::UnicodeString::size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#7b86824a8ce4a308b341309c0924051d">AIUnicodeStringSuite::CaseFindSubString</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the first occurrence of a substring of one Unicode string within a substring of another Unicode string, performing a caseless compare. 
<p>
(Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to search in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The string to compare against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based index in <code>str</code> at which to start the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The maximum number of characters within <code>str2</code> to search for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based character index of the found string, or <code>npos</code> if the string is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="670c9d9eeea268b5dc0dbf00ed3fe052"></a><!-- doxytag: member="AIUnicodeStringSuite::Clear" ref="670c9d9eeea268b5dc0dbf00ed3fe052" args=")(ai::UnicodeString &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI void(* <a class="el" href="struct_a_i_unicode_string_suite.html#670c9d9eeea268b5dc0dbf00ed3fe052">AIUnicodeStringSuite::Clear</a>)(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the contents of a Unicode string. 
<p>
An uninitialized string remains unchanged. (Note that this function does not return an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="449ff7db8c5a9d569840298ab3e43397"></a><!-- doxytag: member="AIUnicodeStringSuite::Compare" ref="449ff7db8c5a9d569840298ab3e43397" args=")(const ai::UnicodeString &amp;str, ai::UnicodeString::size_type pos, ai::UnicodeString::size_type num, const ai::UnicodeString &amp;str2, ai::UnicodeString::size_type startOffset, ai::UnicodeString::size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI int(* <a class="el" href="struct_a_i_unicode_string_suite.html#449ff7db8c5a9d569840298ab3e43397">AIUnicodeStringSuite::Compare</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> pos, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> num, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compares substrings in two Unicode strings. 
<p>
Uninitialized strings are equal to other uninitialized strings and empty strings, and are less than initialized, non-empty strings. (Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The first string (left side of compare). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The 0-based offset for the first character of the first substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>The number of characters in the first substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The second string (right side of compare). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based offset for the first character of the second substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters in the second substring. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the substrings are equal. <br>
 Positive if the first substring is greater than the second. <br>
 Negative if the second substring is greater than the first. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2003219935027332b997d2804744e01d"></a><!-- doxytag: member="AIUnicodeStringSuite::Copy" ref="2003219935027332b997d2804744e01d" args=")(ai::UnicodeString &amp;str, const ai::UnicodeString &amp;str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#2003219935027332b997d2804744e01d">AIUnicodeStringSuite::Copy</a>)(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copies one Unicode string into another. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The destination string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The source string. If empty or uninitialized, the destination string is truncated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e711efe39d8af61ecaa4b760b1419b92"></a><!-- doxytag: member="AIUnicodeStringSuite::Destroy" ref="e711efe39d8af61ecaa4b760b1419b92" args=")(ai::UnicodeString &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#e711efe39d8af61ecaa4b760b1419b92">AIUnicodeStringSuite::Destroy</a>)(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes the contents of a Unicode string, and reset it to an uninitialized state. 
<p>
Any pointers to UTF-16 buffers derived from that string become invalid. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9d2a40e24ddc0acc4b03ebf54c76c58a"></a><!-- doxytag: member="AIUnicodeStringSuite::Empty" ref="9d2a40e24ddc0acc4b03ebf54c76c58a" args=")(const ai::UnicodeString &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#54b1aaa5084ac23c3e956aec86a5f8f1">AIBool8</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#9d2a40e24ddc0acc4b03ebf54c76c58a">AIUnicodeStringSuite::Empty</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reports whether a Unicode string is empty. 
<p>
(Note that this function returns a boolean value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if the string is uninitialized or empty. </dd></dl>

</div>
</div><p>
<a class="anchor" name="043c00445bf40a79e1770af03d4d3900"></a><!-- doxytag: member="AIUnicodeStringSuite::Erase" ref="043c00445bf40a79e1770af03d4d3900" args=")(ai::UnicodeString &amp;str, ai::UnicodeString::size_type startOffset, ai::UnicodeString::size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#043c00445bf40a79e1770af03d4d3900">AIUnicodeStringSuite::Erase</a>)(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases characters from a Unicode string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string, which is modified in place. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based index of the first character to erase. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The maximum number of characters to erase. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>An error if the given position index is not a valid offset into the string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="236c40647d8b46903954f2039a0b0ef2"></a><!-- doxytag: member="AIUnicodeStringSuite::FindChar" ref="236c40647d8b46903954f2039a0b0ef2" args=")(const ai::UnicodeString &amp;str, ai::UnicodeString::UTF32TextChar ch, ai::UnicodeString::size_type startOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#236c40647d8b46903954f2039a0b0ef2">AIUnicodeStringSuite::FindChar</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">ai::UnicodeString::UTF32TextChar</a> ch, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the first occurrence of a character in a substring of a Unicode string. 
<p>
(Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>The character to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based index in <code>str</code> at which to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based character index of the found character, or <code>npos</code> if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="98b0b1f0c4c4be9c0120e3772dc093a6"></a><!-- doxytag: member="AIUnicodeStringSuite::FindFirstNotOf" ref="98b0b1f0c4c4be9c0120e3772dc093a6" args=")(const ai::UnicodeString &amp;str, const ai::UnicodeString &amp;str2, ai::UnicodeString::size_type startOffset, ai::UnicodeString::size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#98b0b1f0c4c4be9c0120e3772dc093a6">AIUnicodeStringSuite::FindFirstNotOf</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches in a Unicode string for the first occurrence of any character that does not appear in a subset of another string. 
<p>
(Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to search in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The string to compare against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based index in <code>str</code> at which to start the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters from the start of <code>str2</code> to compare. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based character index of the found character, or <code>npos</code> if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d59a9358fac097911821db0d02ffe36c"></a><!-- doxytag: member="AIUnicodeStringSuite::FindFirstOf" ref="d59a9358fac097911821db0d02ffe36c" args=")(const ai::UnicodeString &amp;str, const ai::UnicodeString &amp;str2, ai::UnicodeString::size_type startOffset, ai::UnicodeString::size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#d59a9358fac097911821db0d02ffe36c">AIUnicodeStringSuite::FindFirstOf</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the first occurrence of any character from a subset of one Unicode string in a substring of another string. 
<p>
(Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to search in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The string to compare against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based index in <code>str</code> at which to start the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters from the start of <code>str2</code> to compare. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based character index of the found character, or <code>npos</code> if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b062a94858464f8d4d9cb0e932c861e6"></a><!-- doxytag: member="AIUnicodeStringSuite::FindLastNotOf" ref="b062a94858464f8d4d9cb0e932c861e6" args=")(const ai::UnicodeString &amp;str, const ai::UnicodeString &amp;str2, ai::UnicodeString::size_type startOffset, ai::UnicodeString::size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#b062a94858464f8d4d9cb0e932c861e6">AIUnicodeStringSuite::FindLastNotOf</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches in a Unicode string for the last character that does not appear in a substring of another string. 
<p>
(Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to search in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The string to compare against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based index in <code>str</code> at which to start the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters from the start of <code>str2</code> to compare. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based character index of the found character, or <code>npos</code> if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="120103d5246ef50da216abfe2a9ea26b"></a><!-- doxytag: member="AIUnicodeStringSuite::FindLastOf" ref="120103d5246ef50da216abfe2a9ea26b" args=")(const ai::UnicodeString &amp;str, const ai::UnicodeString &amp;str2, ai::UnicodeString::size_type startOffset, ai::UnicodeString::size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#120103d5246ef50da216abfe2a9ea26b">AIUnicodeStringSuite::FindLastOf</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches in a Unicode string for the last character that also appears in a substring of another string. 
<p>
(Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to search in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The string to compare against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based index in <code>str</code> at which to start the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters from the start of <code>str2</code> to compare. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based character index of the found character, or <code>npos</code> if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cc52a52897c791d0e0561a629bac7849"></a><!-- doxytag: member="AIUnicodeStringSuite::FindString" ref="cc52a52897c791d0e0561a629bac7849" args=")(const ai::UnicodeString &amp;str, const ai::UnicodeString &amp;str2, ai::UnicodeString::size_type startOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#cc52a52897c791d0e0561a629bac7849">AIUnicodeStringSuite::FindString</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the first occurrence of an entire string within a substring of a Unicode string. 
<p>
(Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to search in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The string to compare against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based index in <code>str</code> at which to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based character index of the found string, or <code>npos</code> if the string is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a3fcb4827363a4965653b14376413f4"></a><!-- doxytag: member="AIUnicodeStringSuite::FindSubString" ref="5a3fcb4827363a4965653b14376413f4" args=")(const ai::UnicodeString &amp;str, const ai::UnicodeString &amp;str2, ai::UnicodeString::size_type startOffset, ai::UnicodeString::size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#5a3fcb4827363a4965653b14376413f4">AIUnicodeStringSuite::FindSubString</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the first occurrence of a substring of one Unicode string within a substring of another Unicode string. 
<p>
(Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to search in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The string to compare against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based index in <code>str</code> at which to start the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The maximum number of characters within <code>str2</code> to search for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based character index of the found string, or <code>npos</code> if the string is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="93edf6befab1293d5d80becc3fa9ebd1"></a><!-- doxytag: member="AIUnicodeStringSuite::GetAs" ref="93edf6befab1293d5d80becc3fa9ebd1" args=")(const ai::UnicodeString &amp;str, AICharacterEncoding encoding, ai::AutoBuffer&lt; char &gt; &amp;buffer, ai::UnicodeString::size_type &amp;bufferByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#93edf6befab1293d5d80becc3fa9ebd1">AIUnicodeStringSuite::GetAs</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a> encoding, <a class="el" href="classai_1_1_auto_buffer.html">ai::AutoBuffer</a>&lt; char &gt; &amp;buffer, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> &amp;bufferByteCount)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the contents of a Unicode string in a given encoding. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>encoding</em>&nbsp;</td><td>The encoding. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>[out] A buffer in which to return the encoded contents. Need not be initialized prior to the call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bufferByteCount</em>&nbsp;</td><td>[out] A buffer in which to return the number of bytes in the buffer that contain the requested data. The buffer can be larger than this. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cae375503fffb743803ae707c3866e83"></a><!-- doxytag: member="AIUnicodeStringSuite::GetChar" ref="cae375503fffb743803ae707c3866e83" args=")(const ai::UnicodeString &amp;str, ai::UnicodeString::size_type position, ai::UnicodeString::UTF32TextChar &amp;ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#cae375503fffb743803ae707c3866e83">AIUnicodeStringSuite::GetChar</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> position, <a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">ai::UnicodeString::UTF32TextChar</a> &amp;ch)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the UTF-32 code point at an index position in a Unicode string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>The 0-based character offset for the character. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>[out] A buffer in which to return the character. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>An error if the given position is not a valid offset into the string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="155cf6abd6aada91b5968ea46487a3dd"></a><!-- doxytag: member="AIUnicodeStringSuite::HasSurrogates" ref="155cf6abd6aada91b5968ea46487a3dd" args=")(const ai::UnicodeString &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#54b1aaa5084ac23c3e956aec86a5f8f1">AIBool8</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#155cf6abd6aada91b5968ea46487a3dd">AIUnicodeStringSuite::HasSurrogates</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reports whether a Unicode string contains surrogate pairs. 
<p>
(Note that this function returns a boolean value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>True if it contains at least one surrogate pair. </dd></dl>

</div>
</div><p>
<a class="anchor" name="22a78f79f91a81f961d490e330987be7"></a><!-- doxytag: member="AIUnicodeStringSuite::Initialize" ref="22a78f79f91a81f961d490e330987be7" args=")(ai::UnicodeString &amp;str, const char *string, long srcByteLen, AICharacterEncoding encoding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#22a78f79f91a81f961d490e330987be7">AIUnicodeStringSuite::Initialize</a>)(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const char *string, long srcByteLen, <a class="el" href="_a_i_character_encoding_8h.html#12022b5cf661a86a71f3f741955c4054">AICharacterEncoding</a> encoding)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes a Unicode string with the contents of a C string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>[out] A buffer in which to return the Unicode string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>string</em>&nbsp;</td><td>The C string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcByteLen</em>&nbsp;</td><td>The number of bytes in the C string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>encoding</em>&nbsp;</td><td>The encoding type for the new string. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b400768e7d63eed5f69e89146545a889"></a><!-- doxytag: member="AIUnicodeStringSuite::InitializeUTF16" ref="b400768e7d63eed5f69e89146545a889" args=")(ai::UnicodeString &amp;str, const ASUnicode *utfs, ai::UnicodeString::size_type srcUTF16Count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#b400768e7d63eed5f69e89146545a889">AIUnicodeStringSuite::InitializeUTF16</a>)(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="_a_s_types_8h.html#b3d1cbba0a011d599bddd1643cf55b27">ASUnicode</a> *utfs, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> srcUTF16Count)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes a Unicode string with the contents of a UTF-16 encoded string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>[out] A buffer in which to return the Unicode string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>utfs</em>&nbsp;</td><td>The UTF-16 encoded string, an array UTF-16 code units. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcUTF16Count</em>&nbsp;</td><td>The number of UTF-16 code units to be taken from the source string. A value of <code>npos</code> mean that the source string is 0-terminated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0ca65e5ca52b5c50b0f87fa748acedc5"></a><!-- doxytag: member="AIUnicodeStringSuite::InitializeUTF32Char" ref="0ca65e5ca52b5c50b0f87fa748acedc5" args=")(ai::UnicodeString &amp;str, ai::UnicodeString::size_type count, ai::UnicodeString::UTF32TextChar ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#0ca65e5ca52b5c50b0f87fa748acedc5">AIUnicodeStringSuite::InitializeUTF32Char</a>)(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count, <a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">ai::UnicodeString::UTF32TextChar</a> ch)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes a Unicode string with a single UTF-32 code point (character) repeated a given number of times. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>[out] A buffer in which to return the Unicode string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>The UTF code point. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3aae9222264ef574241c52e53c92c92d"></a><!-- doxytag: member="AIUnicodeStringSuite::InitializeZString" ref="3aae9222264ef574241c52e53c92c92d" args=")(ai::UnicodeString &amp;str, ZRef zStringKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#3aae9222264ef574241c52e53c92c92d">AIUnicodeStringSuite::InitializeZString</a>)(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="_a_i_types_8h.html#3be96ecb2582aa04f9c06190d8625dbf">ZRef</a> zStringKey)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes a Unicode string from a ZString. 
<p>
(ZStrings are used internally for localization.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>zStringKey</em>&nbsp;</td><td>The ZString key. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c71ae8d6c6814b91585ebe87cbd1e70b"></a><!-- doxytag: member="AIUnicodeStringSuite::Length" ref="c71ae8d6c6814b91585ebe87cbd1e70b" args=")(const ai::UnicodeString &amp;str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#c71ae8d6c6814b91585ebe87cbd1e70b">AIUnicodeStringSuite::Length</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves the number of UTF-32 code points (characters) in a Unicode string. 
<p>
(Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of characters, 0 for an uninitialized or empty string. </dd></dl>

</div>
</div><p>
<a class="anchor" name="74ded83c6d7144658c1bf0b6cfc4a4df"></a><!-- doxytag: member="AIUnicodeStringSuite::Normalize" ref="74ded83c6d7144658c1bf0b6cfc4a4df" args=")(ai::UnicodeString &amp;str, ai::UnicodeString::NormalizedForm form)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#74ded83c6d7144658c1bf0b6cfc4a4df">AIUnicodeStringSuite::Normalize</a>)(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#003e58acaa5c6aeabea5ecccc8ef5902">ai::UnicodeString::NormalizedForm</a> form)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normalizes a Unicode string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>form</em>&nbsp;</td><td>The normalization format. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="223f03095ba7b6651820e9416920e4fb"></a><!-- doxytag: member="AIUnicodeStringSuite::Resize" ref="223f03095ba7b6651820e9416920e4fb" args=")(ai::UnicodeString &amp;str, ai::UnicodeString::size_type count, ai::UnicodeString::UTF32TextChar ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#223f03095ba7b6651820e9416920e4fb">AIUnicodeStringSuite::Resize</a>)(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count, <a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">ai::UnicodeString::UTF32TextChar</a> ch)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resizes a Unicode string to hold a given number of characters, truncating or padding it as needed. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string, which is modified in place. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The number of characters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>The padding character, if needed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6eb055fb2df5b3472045fbb67c25706a"></a><!-- doxytag: member="AIUnicodeStringSuite::RFindChar" ref="6eb055fb2df5b3472045fbb67c25706a" args=")(const ai::UnicodeString &amp;str, ai::UnicodeString::UTF32TextChar ch, ai::UnicodeString::size_type startOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#6eb055fb2df5b3472045fbb67c25706a">AIUnicodeStringSuite::RFindChar</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8297a74165a80120c668005608b830dd">ai::UnicodeString::UTF32TextChar</a> ch, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the last occurrence of a character in a substring of a Unicode string. 
<p>
(Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>The character to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based index in <code>str</code> at which to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based character index of the found character, or <code>npos</code> if the character is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="acef0c8a9eb1a7238989e087fcb512e8"></a><!-- doxytag: member="AIUnicodeStringSuite::RFindString" ref="acef0c8a9eb1a7238989e087fcb512e8" args=")(const ai::UnicodeString &amp;str, const ai::UnicodeString &amp;str2, ai::UnicodeString::size_type startOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#acef0c8a9eb1a7238989e087fcb512e8">AIUnicodeStringSuite::RFindString</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the last occurrence of an entire string within a substring of a Unicode string. 
<p>
(Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to search in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The string to compare against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based index in <code>str</code> at which to start the search. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based character index of the found string, or <code>npos</code> if the string is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="862a13fabce2a19c8bf225fb1df0e6ca"></a><!-- doxytag: member="AIUnicodeStringSuite::RFindSubString" ref="862a13fabce2a19c8bf225fb1df0e6ca" args=")(const ai::UnicodeString &amp;str, const ai::UnicodeString &amp;str2, ai::UnicodeString::size_type startOffset, ai::UnicodeString::size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#862a13fabce2a19c8bf225fb1df0e6ca">AIUnicodeStringSuite::RFindSubString</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> startOffset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Searches for the last occurrence of a substring of one Unicode string within a substring of another Unicode string. 
<p>
(Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string to search in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The string to compare against. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startOffset</em>&nbsp;</td><td>The 0-based index in <code>str</code> at which to start the search. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The maximum number of characters within <code>str2</code> to search for. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 0-based character index of the found string, or <code>npos</code> if the string is not found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f88bfe2a5dcf90b63de394f8b9ddf807"></a><!-- doxytag: member="AIUnicodeStringSuite::SubStr" ref="f88bfe2a5dcf90b63de394f8b9ddf807" args=")(ai::UnicodeString &amp;subString, const ai::UnicodeString &amp;str, ai::UnicodeString::size_type offset, ai::UnicodeString::size_type count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#f88bfe2a5dcf90b63de394f8b9ddf807">AIUnicodeStringSuite::SubStr</a>)(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;subString, const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> offset, <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a> count)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a substring of a Unicode string. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subString</em>&nbsp;</td><td>[in, out] A Unicode string in which to return the substring. If it is uninitialized on input, it is initialized only if the source string is initialized and not empty. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The source string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>The 0-based index in <code>str</code> at which to start the substring. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The maximum number of characters to place in the new substring. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0b5d1e3e571817f6c1f50aa5182c990b"></a><!-- doxytag: member="AIUnicodeStringSuite::SwapStr" ref="0b5d1e3e571817f6c1f50aa5182c990b" args=")(ai::UnicodeString &amp;str, ai::UnicodeString &amp;str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="_a_i_types_8h.html#c711cafff0c78e894a74bf9022a82e98">AIErr</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#0b5d1e3e571817f6c1f50aa5182c990b">AIUnicodeStringSuite::SwapStr</a>)(<a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str2)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swaps the contents of two Unicode strings. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The first string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>The second string. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6ee2d158f698446ff40b5f660bd24d88"></a><!-- doxytag: member="AIUnicodeStringSuite::UTF_16" ref="6ee2d158f698446ff40b5f660bd24d88" args=")(const ai::UnicodeString &amp;str, const ai::UnicodeString::UTF16Char *&amp;buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AIAPI <a class="el" href="classai_1_1_unicode_string.html#8ad5f247dffa5659a99448bdd43e0901">ai::UnicodeString::size_type</a>(* <a class="el" href="struct_a_i_unicode_string_suite.html#6ee2d158f698446ff40b5f660bd24d88">AIUnicodeStringSuite::UTF_16</a>)(const <a class="el" href="classai_1_1_unicode_string.html">ai::UnicodeString</a> &amp;str, const <a class="el" href="classai_1_1_unicode_string.html#5ef6ba6fadb9aca3e0d44690fba83c10">ai::UnicodeString::UTF16Char</a> *&amp;buffer)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves a read-only pointer to a buffer that contains UTF-16 encoded characters in platform byte order, for a given Unicode string. 
<p>
(Note that this function returns a numeric value, not an error code.) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>The string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>[out] The pointer to the buffer. Can be 0 if the string is empty or uninitialized. Might not be 0 terminated. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The length of the buffer in UTF-16 code units. </dd></dl>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="_a_i_unicode_string_8h-source.html">AIUnicodeString.h</a></ul>

<hr id="decoratehere">
<hr>
<!-- STARTFOOTER -->
</td>
</tr>
<tr>
<td width="15"><spacer type="block" width="15" height="10"></td>
<td><!-- ENDHEADER -->
<!-- start-section: -->
<table border="0" cellpadding="5" cellspacing="5" id="Table2">
<tr>
<td valign="bottom"><a class="qindex" href=
"index.html">Contents</a></td>
<td valign="bottom"><a class="qindex" href="group___suites.html">
Suites</a></td>
<td valign="bottom"><a class="qindex" href="annotated.html">
Classes</a></td>
<td valign="bottom"><a class="qindex" href="classes.html">
Class Index</a></td>
<td valign="bottom"><a class="qindex" href="functions.html">
Member Index</a></td>
</tr>
</table>
</td>
</tr>
<!-- </table> --></table>
<table border="0" cellpadding="0" cellspacing="0" width="745" id=
"Table3">
<tr height="30">
<td colspan="3" height="30"><spacer type="block" height="30"></td>
</tr>
<tr height="45">
<td width="20"><spacer type="block" width="20" height="45"></td>
<td width="115"><img src="asn.gif" width="114"
height="45" border="0" alt="Adobe Solutions Network"></td>
<td width="610"><spacer type="block" width="610" height="45"></td>
</tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="745" id=
"Table4">
<tr height="10">
<td width="20" height="10"><spacer type="block" width="20" height=
"10"></td>
<td width="705" height="10"><spacer type="block" height="10"></td>
<td width="20" height="10"><spacer type="blockheight=10"></td>
</tr>
<tr height="3">
<td width="10" align="right"><spacer type="block" width="10"
height="1"></td>
<td width="705" background="1dot.gif" alt=""><spacer type="block"
width="1" height="3"></td>
<td width="10"><spacer type="block" width="10" height="1"></td>
</tr>
<tr height="10">
<td colspan="3"><spacer type="block" height="10"></td>
</tr>
</table>
<table border="0" cellpadding="0" cellspacing="0" width="745" id=
"Table5">
<tr>
<td width="20">&nbsp;</td>
<td width="725" valign="top">
<table border="0" cellpadding="0" cellspacing="0" id="Table6">
<tr>
<td colspan="13" valign="top" align="left" class="bio">Copyright
&#169; 2007 Adobe Systems Incorporated. All rights reserved.</td>
</tr>
<tr height="3">
<td colspan="13" height="3"><spacer type="block" width="20" height=
"3"></td>
</tr>
<tr>
<td valign="top"><a href="http://www.adobe.com/misc/copyright.html"
class="footerlink">Terms of Use</a></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td width="1" background="1dot.gif"><spacer type="block" width="1"
height="1"></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td valign="top"><a href="http://www.adobe.com/misc/privacy.html"
class="footerlink">Online Privacy Policy</a></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td width="1" background="1dot.gif"><spacer type="block" width="1"
height="1"></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td valign="top"><a href="http://access.adobe.com" class=
"footerlink">Adobe and accessibility</a></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td width="1" background="1dot.gif"><spacer type="block" width="1"
height="1"></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td valign="top"><a href=
"http://www.adobe.com/aboutadobe/antipiracy/main.html" class=
"footerlink">Avoid software piracy</a></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td width="1" background="1dot.gif"><spacer type="block" width="1"
height="1"></td>
<td width="5"><spacer type="block" width="5" height="10"></td>
<td valign="top"><a href="http://www.adobe.com/misc/agreement.html"
class="footerlink">Permissions and Trademarks</a></td>
</tr>
<tr height="40">
<td colspan="12" height="40"><spacer type="block" width="20"
height="40"></td>
<td height="40"><img src="1ptrans.gif" width="20" height=
"40">&nbsp;</td>
</tr>
</table>
</td>
</tr>
</table>
</body>
</html>
